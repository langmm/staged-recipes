diff --git a/.gitignore b/.gitignore
index 0925263..b9d6771 100644
--- a/.gitignore
+++ b/.gitignore
@@ -80,8 +80,6 @@ target/
 
 # svn
 .svn
-
-
 # sphinx autogen file
 doc/_dvlpt/
 
diff --git a/.pkglts/pkg_cfg.json b/.pkglts/pkg_cfg.json
index 9645464..54388ed 100644
--- a/.pkglts/pkg_cfg.json
+++ b/.pkglts/pkg_cfg.json
@@ -3,7 +3,7 @@
     "auto_install": true,
     "install_front_end": "stdout",
     "use_prompts": false,
-    "version": 3
+    "version": 8
   },
   "base": {
     "authors": [
@@ -25,11 +25,13 @@
       ]
     ],
     "namespace": "openalea",
+    "namespace_method": "setuptools",
     "pkgname": "deploy",
     "url": "https://openalea.gforge.inria.fr"
   },
   "doc": {
     "description": "OpenAlea.Deploy support the installation of OpenAlea packages via the network and manage their dependencies. It is an extension of Setuptools.",
+    "fmt": "rst",
     "keywords": [
       "setuptools",
       "openalea"
@@ -44,7 +46,7 @@
     "name": "cecill-c",
     "organization": "CIRAD/Inria",
     "project": "{{ base.pkgname }}",
-    "year": 2016
+    "year": "2016-2017"
   },
   "pysetup": {
     "intended_versions": [
@@ -54,12 +56,15 @@
   },
   "sphinx": {
     "autodoc_dvlpt": true,
+    "build_dir": "build/sphinx",
     "theme": "default"
   },
-  "test": {},
+  "test": {
+    "suite_name": "nose"
+  },
   "version": {
     "major": 2,
     "minor": 1,
-    "post": 1
+    "post": 6
   }
 }
\ No newline at end of file
diff --git a/.pkglts/pkg_hash.json b/.pkglts/pkg_hash.json
index ac2ff33..3535c1b 100644
--- a/.pkglts/pkg_hash.json
+++ b/.pkglts/pkg_hash.json
@@ -1,6 +1,6 @@
 {
   ".gitignore": {
-    "github": "PphBqiMKxF8DR59MJbCJ+W1Y6U+9J3QMWIFgEFj4oJpstJqPpS6P/qCJ1rSBb8ihe55ZtlkRUs9+2IzvuISxlA=="
+    "github": "YAjSHH+c+Q5KVsboKYSxqkMJFVsI+n4PuYrUe43/bcqEtNV5qH/zdKnKjWu4+E2ToReknaQq2EtFNh7rXMzywg=="
   }, 
   "AUTHORS.rst": {
     "doc": "mr4dDvb808KCdcLSRWe9brxcIBamJp3DMpFzoEhHCeSLmr7Q0QfrNRZ79dnneEyWHgcs2srtibLIZlGOq1S0rQ=="
@@ -22,7 +22,7 @@
   "doc/_static/nonempty.txt": {}, 
   "doc/authors.rst": {}, 
   "doc/conf.py": {
-    "sphinx": "L2BgoD4RtluNyBy0I7xJvIdvrswg9S4TNQvRWIc9VLtmFOAwMLV3eqxQowQOGYCqLlRxigfl63xDkYU6tWxTfg=="
+    "sphinx": "rqh++Gu59dGMFDMpuaR//a78YCL4/qg//OWFyJ7/zvwmRXBBfsOCT2xG5o9S7ONmrZDqRFwnLAa5NQ4koxfS0g=="
   }, 
   "doc/contributing.rst": {}, 
   "doc/history.rst": {}, 
@@ -34,20 +34,23 @@
   "doc/readme.rst": {}, 
   "doc/usage.rst": {}, 
   "dvlpt_requirements.txt": {
-    "pysetup": "iVZzb/1gNMgo9kQ5ZWaIE2HrO9m4aClusQCdtA1zgxu2zmzOke81noQxg7d0TBCD/YAUaJtu7pqYz8fihmyURg=="
+    "pysetup": "nPozWSlftiTzMVLgr7jL6l5qodFZuCF27jiL3QgQmkqcLQnlw7VhtpPNbG3ssTlEvOmnS5tY5lPIc3pfgccV4A=="
   }, 
   "requirements.txt": {
     "pysetup": "/5djJXLbrvuFk7LIgtfgYR8RnQrY5BEmOB4zEd0PrKeswR/8sQkzj4yKy7Zl3LAdRzYjPDhWiRkS1oMCG4FX7Q=="
   }, 
   "setup.cfg": {
-    "pysetup": "1iCSDvs9xY0GOgde2dHQdpu5siqLRSbSiVZr6vEMin886x1NKrTLw0f1AJuSUwPfsoXa1a1EfRsDFadXx3Qy8A=="
+    "pysetup": "OjcWBMhd1noe+8jyIMjkmHkS5ovZRh+0ms8ZtQyCgroYEWoqcBfo37W/Ee3pgRrzUXBD2CXFbMa4dFKOl+kr/w=="
+  }, 
+  "setup.py": {
+    "pysetup.call": "2wHuP94SpWKZpqOzExkQGTxnhGPgBHK3qOdPn0Ncstj5FkZ7FBGGM/inqAXaI4QLKQtTNlOUYRGSkYUWAUcf1w==", 
+    "pysetup.kwds": "QxTCOd0FbtHQYk4C/wig901iSFbA/smWjK1zFp/NpCJob9JaqhM9SGBp1IxMlmKaZn3D06lKI5RHvyKbxrHJEw=="
   }, 
-  "setup.py": {}, 
   "src/openalea/deploy/__init__.py": {
     "base": "gR33dW0qqYmsV9NSNB+DD8XmuxnC2t0mKjnMoU5728qh97fSER6MbX+3QKxpZDLByZToaAay4xhx8acxketJmA=="
   }, 
   "src/openalea/deploy/version.py": {
-    "version": "ytFzll5R829r+RLL+x3MJrZS8foZCBBlJttTbAb4d8Wlsp8A5AV93WGB4vwxmgsKtFs+zOmD21FIv9XjAvuevA=="
+    "version": "ChPO3wliFOVQq5aqh7wQjnS0fqC7A3RPBg1P9fKI+91DwmdDJhgchQEbp5fwkWnUel4x8cQ0Nen444O1riQUGQ=="
   }, 
   "test/__init__.py": {}
 }
\ No newline at end of file
diff --git a/.travis.yml b/.travis.yml
new file mode 120000
index 0000000..95c89cf
--- /dev/null
+++ b/.travis.yml
@@ -0,0 +1 @@
+travis.yml
\ No newline at end of file
diff --git a/MANIFEST.in b/MANIFEST.in
index 2c37212..5cf9345 100644
--- a/MANIFEST.in
+++ b/MANIFEST.in
@@ -23,3 +23,7 @@ include doc/make.bat
 
 
 # #}
+
+include src/openalea/deploy/system_dependencies/*.patch
+include src/openalea/deploy/system_dependencies/*.in
+include src/openalea/deploy/system_dependencies/*.sub
diff --git a/README.rst b/README.rst
index 71b9937..eb1dfa8 100644
--- a/README.rst
+++ b/README.rst
@@ -1,5 +1,14 @@
+.. image:: https://img.shields.io/badge/License-CeCILL_C-blue.svg
+   :target: http://www.cecill.info/licences/Licence_CeCILL-C_V1-en.html
+
+.. image:: https://travis-ci.org/openalea/deploy.svg?branch=master
+    :target: https://travis-ci.org/openalea/deploy
+
+.. image:: https://ci.appveyor.com/api/projects/status/8d3qs5f00wriryo2/branch/master?svg=true
+   :target: https://ci.appveyor.com/project/fredboudon/deploy
+
 ========================
-openalea.deploy
+Openalea.Deploy
 ========================
 
 .. {# pkglts, doc
diff --git a/appveyor.yml b/appveyor.yml
new file mode 100644
index 0000000..836703e
--- /dev/null
+++ b/appveyor.yml
@@ -0,0 +1,55 @@
+platform:
+  - x86
+  - x64
+
+environment:
+  matrix:
+    - CONDA_RECIPE: conda
+      CONDA_VERSION: 2
+    - CONDA_RECIPE: conda
+      CONDA_VERSION: 3
+
+# matrix:
+#   allow_failures:
+#     - platform: x86
+#       CONDA_RECIPE: conda
+#       CONDA_VERSION: 3
+#     - platform: x64
+#       CONDA_RECIPE: conda
+#       CONDA_VERSION: 3
+
+install:
+  - git clone https://github.com/OpenAlea/appveyor-ci.git
+  - cd appveyor-ci
+  - call install.bat
+    
+before_build:
+  - call before_build.bat
+
+build_script:
+  - call build_script.bat
+  
+after_build:
+  - call after_build.bat
+
+deploy:
+  provider: Script
+ 
+before_deploy:
+  - call before_deploy.bat
+
+deploy_script:
+  - call deploy_script.bat
+
+after_deploy:
+  - call after_deploy.bat
+
+on_success:
+  - call on_success.bat
+
+on_failure:
+  - call on_failure.bat
+
+on_finish:
+  - call on_finish.bat
+    
diff --git a/doc/conf.py b/doc/conf.py
index 2918629..3520c6c 100644
--- a/doc/conf.py
+++ b/doc/conf.py
@@ -2,7 +2,7 @@
 #!/usr/bin/env python
 # -*- coding: utf-8 -*-
 #
-# Package (Undefined, u'deploy') documentation build configuration file, created by
+# Package deploy documentation build configuration file, created by
 # sphinx-quickstart on Tue Jul  9 22:26:36 2013.
 #
 # This file is execfile()d with the current directory set to its
@@ -86,7 +86,7 @@ master_doc = 'index'
 
 # General information about the project.
 project = u'openalea.deploy'
-copyright = u'2015, openalea.deploy'
+copyright = u'2016-2017, openalea.deploy'
 
 # The version info for the project you're documenting, acts as replacement
 # for |version| and |release|, also used in various other places throughout
@@ -315,30 +315,15 @@ texinfo_documents = [
 # use apidoc to generate developer doc
 import os
 from os import path
-from sphinx.apidoc import create_modules_toc_file, recurse_tree
+from sphinx.apidoc import main
 
 
-class Opt(object):
-    pass
+rootpath = path.abspath(path.join(project_root, "src"))
+destdir = path.abspath(path.join(project_root, "doc", "_dvlpt"))
 
+if not path.isdir(destdir):
+    os.makedirs(destdir)
 
-rootpath = path.abspath(path.join(project_root, "src"))
-opts = Opt()
-opts.modulefirst = None
-opts.separatemodules = None
-opts.noheadings = None
-opts.destdir = path.abspath(path.join(project_root, "doc", "_dvlpt"))
-opts.suffix = source_suffix[1:]
-opts.dryrun = None
-opts.force = None
-opts.header = 'src'
-opts.maxdepth = 4
-opts.includeprivate = False
-
-if not path.isdir(opts.destdir):
-    os.makedirs(opts.destdir)
-
-modules = recurse_tree(rootpath, [], opts)
-create_modules_toc_file(modules, opts)
+main(['-e', '-o', destdir, '-d', '4', '-s', source_suffix[1:], '--force', rootpath])
 
 # #}
diff --git a/dvlpt_requirements.txt b/dvlpt_requirements.txt
index 691ec5c..39dead0 100644
--- a/dvlpt_requirements.txt
+++ b/dvlpt_requirements.txt
@@ -1,6 +1,6 @@
 # {# pkglts, pysetup
-mock
-nose
-sphinx
+mock # conda install mock
+nose # conda install nose
+sphinx # conda install sphinx
 
 # #}
diff --git a/setup.cfg b/setup.cfg
index e1410d7..5432b88 100644
--- a/setup.cfg
+++ b/setup.cfg
@@ -14,6 +14,9 @@ detailed-errors=1
 # pdb=1
 # pdb-failures=1
 
+[build_sphinx]
+build-dir=build/sphinx
+
 
 
 # #}
@@ -28,17 +31,17 @@ package = OpenAlea.Deploy
 package = deploy
 project = openalea
 
-[bdist_rpm]
-requires = python >= 2.6
-           python-setuptools >= 0.6
-build_requires = python >= 2.6
-           python-devel >= 2.6
-           python-setuptools >= 0.6
-provides = %{name} = %{version}
-obsoletes = %{name} < %{version}
-doc_files = AUTHORS.txt ChangeLog.txt README.rst LICENSE.txt
-python = /usr/bin/python
-packager = OpenAlea Consortium
-changelog =
-  * Mon Oct 11 2010 OpenAlea Consortium 0.9
-  - add bdist_rpm configuration files to create RPM automatically
+# [bdist_rpm]
+# requires = python >= 2.6
+#            python-setuptools >= 0.6
+# build_requires = python >= 2.6
+#            python-devel >= 2.6
+#            python-setuptools >= 0.6
+# provides = %{name} = %{version}
+# obsoletes = %{name} < %{version}
+# doc_files = AUTHORS.txt ChangeLog.txt README.rst LICENSE.txt
+# python = /usr/bin/python
+# packager = OpenAlea Consortium
+# changelog =
+#   * Mon Oct 11 2010 OpenAlea Consortium 0.9
+#   - add bdist_rpm configuration files to create RPM automatically
diff --git a/setup.py b/setup.py
index 93c8a72..71b7062 100644
--- a/setup.py
+++ b/setup.py
@@ -3,58 +3,53 @@
 
 """Setup.py file generated by PkgLTS."""
 
-# {{pkglts pysetup.kwds,
+# {# pkglts, pysetup.kwds
 # format setup arguments
-from os import walk
-from os.path import abspath, normpath
-from os.path import join as pj
+
 from setuptools import setup, find_packages
 
 
-short_descr = "OpenAlea.Deploy support the installation of OpenAlea packages via the network and manage their dependencies. It is an extension of Setuptools. "
+short_descr = "OpenAlea.Deploy support the installation of OpenAlea packages via the network and manage their dependencies. It is an extension of Setuptools."
 readme = open('README.rst').read()
-history = open('HISTORY.rst').read().replace('.. :changelog:', '')
-
-
-def parse_requirements(fname):
-    with open(fname, 'r') as f:
-        txt = f.read()
+history = open('HISTORY.rst').read()
 
-    reqs = []
-    for line in txt.splitlines():
-        line = line.strip()
-        if len(line) > 0 and not line.startswith("#"):
-            reqs.append(line)
 
-    return reqs
-
-# find version number in /src/$pkg_pth/version.py
+# find version number in src/openalea/deploy/version.py
 version = {}
 with open("src/openalea/deploy/version.py") as fp:
     exec(fp.read(), version)
 
 
-
 setup_kwds = dict(
     name='openalea.deploy',
     version=version["__version__"],
     description=short_descr,
     long_description=readme + '\n\n' + history,
     author="openalea",
-    author_email='christophe dot pradal at cirad dot fr',
+    author_email="openalea@inria.fr",
     url='https://openalea.gforge.inria.fr',
-    license="cecill-c",
+    license='cecill-c',
     zip_safe=False,
 
     packages=find_packages('src'),
+    namespace_packages=['openalea'],
     package_dir={'': 'src'},
-    install_requires=parse_requirements("requirements.txt"),
-    tests_require=parse_requirements("dvlpt_requirements.txt"),
+    setup_requires=[
+        ],
+    install_requires=[
+        'six'
+        ],
+    tests_require=[
+        "mock",
+        "nose",
+        "sphinx",
+        ],
     entry_points={},
     keywords='setuptools, openalea',
+    
     test_suite='nose.collector',
-)
-# }}
+    )
+# #}
 # change setup_kwds below before the next pkglts tag
 
 entry_points = {
@@ -104,8 +99,9 @@ entry_points = {
 
 }
 setup_kwds["entry_points"] = entry_points
+setup_kwds["include_package_data"] = True
 
 # do not change things below
-# {{pkglts pysetup.call,
+# {# pkglts, pysetup.call
 setup(**setup_kwds)
-# }}
+# #}
diff --git a/src/openalea/__init__.py b/src/openalea/__init__.py
index a9a6a7a..dc1b6c0 100644
--- a/src/openalea/__init__.py
+++ b/src/openalea/__init__.py
@@ -1,4 +1,3 @@
-
-# {#pkglts,
+# {# pkglts, base
 __import__('pkg_resources').declare_namespace(__name__)
 # #}
diff --git a/src/openalea/deploy/__init__.py b/src/openalea/deploy/__init__.py
index 59c0008..de1fe55 100644
--- a/src/openalea/deploy/__init__.py
+++ b/src/openalea/deploy/__init__.py
@@ -6,7 +6,7 @@ __version__ = version.__version__
 
 # #}
 
-from util import *
+from .util import *
 
-from doc_tools import *
-from autosum_generator import *
+from .doc_tools import *
+from .autosum_generator import *
diff --git a/src/openalea/deploy/alea_config.py b/src/openalea/deploy/alea_config.py
index cda8f39..14e002e 100644
--- a/src/openalea/deploy/alea_config.py
+++ b/src/openalea/deploy/alea_config.py
@@ -13,10 +13,11 @@ __license__ = "Cecill-C"
 __revision__ = " $Id$"
 
 # from install_lib import get_default_dyn_lib
-from install_lib import get_dyn_lib_dir
+from .install_lib import get_dyn_lib_dir
 # from util import check_system
-from command import set_env
+from .command import set_env
 from optparse import OptionParser
+from .util import is_conda_env
 
 
 def main():
@@ -34,8 +35,11 @@ def main():
 
     (options, _) = parser.parse_args()
 
+    if is_conda_env():
+        print('WARNING: Do not use alea_config in a conda environment.')
+
     if options.printdir:
-        print get_dyn_lib_dir()
+        print(get_dyn_lib_dir())
 
     if (options.lib_dir or not options.printdir):
         set_env(options.lib_dir)
diff --git a/src/openalea/deploy/alea_update.py b/src/openalea/deploy/alea_update.py
index 75f65ae..0b4949f 100644
--- a/src/openalea/deploy/alea_update.py
+++ b/src/openalea/deploy/alea_update.py
@@ -32,22 +32,22 @@ def remove_egg(project_name, dist):
     location = dist.location
 
     try:
-        print "Remove ", project_name, version, location
+        print ("Remove ", project_name, version, location)
         if (os.path.isdir(location)):
-            print "Remove directory : %s" % (location,)
+            print ("Remove directory : %s" % (location,))
             shutil.rmtree(location)
         else:
-            print "Remove file %s" % (location)
+            print ("Remove file %s" % (location))
             os.remove(location)
             return True
 
-    except Exception, e:
-        print e
+    except Exception as e:
+        print (e)
         return False
 
     except:
-        print "Unexpected error:", sys.exc_info()[0]
-        print "Please check you have permission to remove packages. "
+        print ("Unexpected error:", sys.exc_info()[0])
+        print ("Please check you have permission to remove packages. ")
         return False
 
 
@@ -73,7 +73,7 @@ def update_all():
     env = Environment()
 
     for project_name in env._distmap.keys():
-        print "Update %s" % (project_name)
+        print ("Update %s" % (project_name))
         alea_install_U(project_name)
 
 
diff --git a/src/openalea/deploy/autosum_generator.py b/src/openalea/deploy/autosum_generator.py
index 5d708d1..53b8eae 100644
--- a/src/openalea/deploy/autosum_generator.py
+++ b/src/openalea/deploy/autosum_generator.py
@@ -19,7 +19,7 @@ Small functions to manipulate autosum files
 """
 
 from os.path import join, dirname, basename, splitext
-from list_modules import list_modules
+from .list_modules import list_modules
 
 
 def generate_autosum(pkg_name, filename):
@@ -38,7 +38,7 @@ def generate_autosum(pkg_name, filename):
      - `filename` (str) - name of the file in which to write the autosum
     """
     # find package root directory
-    exec "import %s as pkg" % pkg_name
+    exec ("import %s as pkg" % pkg_name)
 
     pkg_dir = dirname(pkg.__file__)
     pkg_dir_name = basename(pkg_dir)
@@ -68,7 +68,7 @@ Reference guide
 
     modules = []
 
-    print pkg_dir
+    print (pkg_dir)
     for mod_name in list_modules(pkg_dir):
         gr = mod_name.split(".")
         if not gr[-1].startswith("_") \
@@ -80,7 +80,7 @@ Reference guide
 
     for mod_dec in modules:
         full_mod_name = ".".join([pkg_name] + mod_dec)
-        print full_mod_name
+        print (full_mod_name)
         txt += """
 .. currentmodule:: %s
 """ % full_mod_name
diff --git a/src/openalea/deploy/command.py b/src/openalea/deploy/command.py
index 461f675..3046053 100644
--- a/src/openalea/deploy/command.py
+++ b/src/openalea/deploy/command.py
@@ -17,6 +17,8 @@
 To extend setuptools, we have to replace setuptools function with our
 own function.
 """
+from __future__ import print_function
+
 
 __license__ = "Cecill-C"
 __revision__ = " $Id$ "
@@ -50,14 +52,19 @@ from distutils.errors import DistutilsSetupError
 # from distutils.util import convert_path
 from distutils.dir_util import mkpath
 import re
-import new
-import ConfigParser
-from util import get_all_lib_dirs, get_all_bin_dirs, DEV_DIST
-from install_lib import get_dyn_lib_dir
-from util import get_base_dir, get_repo_list, OPENALEA_PI
-from util import is_virtual_env, is_conda_env
-from environ_var import set_lsb_env, set_win_env
-import install_lib
+try:
+    # Python 3
+    import configparser
+except:
+    # Python 2
+    import ConfigParser as configparser
+
+from .util import get_all_lib_dirs, get_all_bin_dirs, DEV_DIST
+from .install_lib import get_dyn_lib_dir
+from .util import get_base_dir, get_repo_list, OPENALEA_PI
+from .util import is_virtual_env, is_conda_env, is_conda_build, conda_prefix
+from .environ_var import set_lsb_env, set_win_env
+from . import install_lib
 
 
 # Utility
@@ -74,7 +81,7 @@ def copy_data_tree(src, dst, exclude_pattern=['(RCS|CVS|\.svn)', '.*\~']):
     outfiles = []
 
     for p in exclude_pattern:
-        names = filter(lambda x: not (re.match(p, x)), names)
+        names = [x for x in names if not (re.match(p, x))]
 
     for n in names:
         src_name = os.path.join(src, n)
@@ -107,7 +114,11 @@ def has_ext_modules(dist):
 
 def set_has_ext_modules(dist):
     """ Set new function handler to dist object """
-    m = new.instancemethod(has_ext_modules, dist, Distribution)
+    from types import MethodType as instancemethod
+    if sys.version_info[0] == 2:
+        m = instancemethod(has_ext_modules, dist, Distribution)
+    else:
+        m = instancemethod(has_ext_modules, dist)
     dist.has_ext_modules = m
 
 
@@ -198,6 +209,10 @@ class build_ext(old_build_ext):
         # Add lib_dirs and include_dirs in packages
         # Copy the directories containing the files generated
         # by scons and the like.
+        if is_conda_build():
+            print('Building directly with conda. Skip the bin, include and lib dirs.')
+            return old_build_ext.run(self)
+
         for d in (self.distribution.lib_dirs,
                   self.distribution.inc_dirs,
                   self.distribution.bin_dirs,
@@ -345,10 +360,10 @@ def write_keys_arg(cmd, basename, filename, force=False):
     argname = os.path.splitext(basename)[0]
     value = getattr(cmd.distribution, argname, None)
     if value is not None:
-        value = '\n'.join(value.keys()) + '\n'
+        value = '\n'.join(list(value.keys())) + '\n'
     cmd.write_or_delete_file(argname, filename, value, force)
     if is_conda_env():
-        print 'CONDA EGG WRITER: ', cmd, basename, filename, value
+        print('CONDA EGG WRITER: ', cmd, basename, filename, value)
         pass
 
 # SCons Management
@@ -372,7 +387,7 @@ class scons(Command):
                      'External parameters to pass to scons.'),
                     ('scons-path=',
                      None,
-                     'Optional scons executable path. eg : C:\Python27\scons.bat for windows.')]
+                     'Optional scons executable path. eg : C:\Python27\scons.bat for windows.'),]
 
     def initialize_options(self):
         self.outfiles = None
@@ -381,6 +396,7 @@ class scons(Command):
         self.build_dir = None  # build directory
         self.scons_ext_param = None  # scons external parameters
         self.scons_path = None
+        self.scons_install = None # install in conda env
 
     def finalize_options(self):
 
@@ -394,6 +410,12 @@ class scons(Command):
         if (not self.scons_parameters):
             self.scons_parameters = ""
 
+        if not self.scons_install:
+            if is_conda_env():
+                self.scons_install = True
+
+
+
         self.set_undefined_options('build_ext',
                                    ('build_lib', 'build_dir'),
                                    ('scons_ext_param', 'scons_ext_param'),
@@ -442,7 +464,13 @@ class scons(Command):
                                           param, externp])
                 commandstr = command + ' ' + command_param
 
-                print commandstr
+                # Run scons install   
+                # To correctly dispatch the dll in the conda prefix bin dir
+                if self.scons_install:
+
+                    commandstr += ' install'
+
+                print(commandstr)
 
                 # Run SCons
                 if (subprocess_enabled):
@@ -454,13 +482,13 @@ class scons(Command):
                 if (retval != 0):
                     raise SconsError()
 
-            except SconsError, i:
-                print i, " Failure..."
+
+            except SconsError as i:
+                print(i, " Failure...")
                 sys.exit(1)
 
-            except Exception, i:
-                print "!! Error : Cannot execute scons command:", i,
-                print " Failure..."
+            except Exception as i:
+                print("!! Error : Cannot execute scons command:", i, " Failure...")
                 sys.exit(1)
 
 
@@ -522,7 +550,7 @@ class cmake(Command):
                 cmake_cmd_param = file_param
                 commandstr = cmake_cmd + ' ' + cmake_cmd_param
 
-                print commandstr
+                print(commandstr)
 
                 if not os.path.isdir('build-cmake'):
                     os.mkdir('build-cmake')
@@ -554,13 +582,12 @@ class cmake(Command):
 
                 os.chdir(os.pardir)
 
-            except CMakeError, i:
-                print i, " Failure..."
+            except CMakeError as i:
+                print(i, " Failure...")
                 sys.exit(1)
 
-            except Exception, i:
-                print "!! Error : Cannot execute cmake command:", i,
-                print " Failure..."
+            except Exception as i:
+                print("!! Error : Cannot execute cmake command:", i, " Failure...")
                 sys.exit(1)
 
 
@@ -625,7 +652,7 @@ except ImportError:
         """ Run command """
 
         for namespace in self.namespaces:
-            print "creating %s namespace" % (namespace)
+            print("creating %s namespace" % (namespace))
             self.create_empty_namespace(namespace)
 
 
@@ -653,7 +680,7 @@ class install(old_install):
         if (not self.install_dyn_lib):
             self.install_dyn_lib = get_dyn_lib_dir()
         self.install_dyn_lib = os.path.expanduser(self.install_dyn_lib)
-        print 'INSTALL LIB: ', self.install_dyn_lib
+        print('INSTALL LIB: ', self.install_dyn_lib)
         old_install.finalize_options(self)
 
     def do_egg_install(self):
@@ -743,6 +770,7 @@ class alea_install(old_easy_install):
 
     def set_system(self):
         """ Set environment """
+
         if ("win32" in sys.platform):
             # install pywin32
             try:
@@ -772,7 +800,7 @@ class alea_install(old_easy_install):
 
     def postinstall(self, dist):
         """ call postinstall scripts """
-        print "Post installation"
+        print("Post installation")
 
         if (dist):
             pkg_resources.require(dist.project_name)
@@ -791,19 +819,19 @@ class alea_install(old_easy_install):
                 if (win32dir not in os.environ['PATH']):
                     os.environ['PATH'] += ";" + win32dir
             except:
-                print "!!Error : pywin32 package not found. Please install it before."
+                print("!!Error : pywin32 package not found. Please install it before.")
 
         # process postinstall
         for s in pkg_resources.yield_lines(lstr):
-            print "Executing %s" % (s)
+            print("Executing %s" % (s))
 
             try:
                 module = __import__(s, globals(), locals(), s.split('.'))
                 module.install()
 
-            except Exception, e:
-                print "Warning : Cannot execute %s" % (s,)
-                print e
+            except Exception as e:
+                print("Warning : Cannot execute %s" % (s,))
+                print(e)
 
 
 def set_env(dyn_lib=None):
@@ -818,25 +846,26 @@ def set_env(dyn_lib=None):
     if condaenv:
         # print "CONDA Environment Detected. set_env do something:", dyn_lib
         dyn_lib = install_lib.install_lib(dyn_lib)
+
         # print list(get_all_lib_dirs(precedence=DEV_DIST))
         return
 
-    print "Install dynamic or share libs "
+    print("Install dynamic or share libs ")
 
     # lib_dirs = list(get_all_lib_dirs())
     dyn_lib = install_lib.install_lib(dyn_lib)
 
-    print "Setting environment variables"
+    print("Setting environment variables")
 
     # Get all the dirs containing shared libs of the devel pkg
     # plus the global shared lib directory.
     lib_dirs = list(get_all_lib_dirs(precedence=DEV_DIST)) + [dyn_lib]
     bin_dirs = list(get_all_bin_dirs())
 
-    print "The following directories contains shared library :", '\n'.join(
-        lib_dirs), '\n'
-    print "The following directories contains binaries :", '\n'.join(
-        bin_dirs), '\n'
+    print("The following directories contains shared library :", '\n'.join(
+        lib_dirs), '\n')
+    print("The following directories contains binaries :", '\n'.join(
+        bin_dirs), '\n')
 
     # To fix the lost of access rights during the step of extract and instal .egg on Linux and MacOsX
     for d in bin_dirs:
@@ -851,7 +880,7 @@ def set_env(dyn_lib=None):
             pass
 
     if virtualenv:
-        print "EDIT the activate script to setup PATH and/or LD_LIBRARY_PATH"
+        print("EDIT the activate script to setup PATH and/or LD_LIBRARY_PATH")
         return
 
     all_dirs = set(lib_dirs + bin_dirs)
@@ -868,7 +897,7 @@ def set_env(dyn_lib=None):
             # vars.append('DYLD_FRAMEWORK_PATH=$OPENALEA_LIB')
         set_lsb_env('openalea', vars)
     except:
-        print vars
+        print(vars)
         return
 
 
@@ -1047,8 +1076,8 @@ class egg_upload(Command):
                 self.release = '.'.join(version.split('.')[0:2])
                 warnings.warn(
                     'Release not provided but found one in the setup.py (%s).' % self.release)
-            except Exception, e:
-                print e, 'release could not be found.'
+            except Exception as e:
+                print(e, 'release could not be found.')
                 import sys
                 sys.exit(0)
 
@@ -1088,7 +1117,7 @@ class egg_upload(Command):
         if self.yes_to_all == 1:
             arguments += ' --yes-to-all '
 
-        print 'Command that will be called is : \n\tgforge_upload %s' % arguments
+        print('Command that will be called is : \n\tgforge_upload %s' % arguments)
         # password is afterwards so that it does not appear on the screen!
         if self.password:
             arguments += ' --password %s' % self.password
@@ -1164,7 +1193,7 @@ class pylint(Command):
             self.pylint_options = ''
 
     def run(self):
-        print '    PYLINT processing'
+        print('    PYLINT processing')
         if self.pylint_packages:
             # print '    Processing ' + self.pylint_packages + ' through pylint'
             cmd = 'pylint '
@@ -1172,13 +1201,13 @@ class pylint(Command):
                 cmd += package.replace('/', os.sep) + os.sep + '*.py '
             cmd += ' ' + self.pylint_options
             cmd += self.pylint_base_options
-            print cmd
+            print(cmd)
             status = subprocess.call(cmd,
                                      stdout=open(self.output_filename, 'w+'),
                                      stderr=None, shell=True)
             if status != 0:
-                print 'This command returns status (%s) different from 0.' % \
-                      str(status)
+                print('This command returns status (%s) different from 0.' % \
+                      str(status))
             cmd = 'tail -n 1 %s ; grep \"Your code\"  %s ' % (
                 self.output_filename, self.output_filename)
             subprocess.call(cmd, stdout=None, stderr=None, shell=True)
@@ -1230,10 +1259,10 @@ class upload_sphinx(Command):
                 """Project must be vplants, alinea or openalea. Check your setup.cfg pupload_sphinx] section. %s provided""" % self.project)
 
         if self.stable is False:
-            print "Documentation will be uploaded to unstable directory"
+            print("Documentation will be uploaded to unstable directory")
             self.destination = '/home/groups/openalea/htdocs/beta_doc'
         else:
-            print "Documentation will be uploaded to stable directory"
+            print("Documentation will be uploaded to stable directory")
             self.destination = '/home/groups/openalea/htdocs/doc'
 
         if (not self.release):
@@ -1245,19 +1274,19 @@ class upload_sphinx(Command):
                 self.release = version
 
         if not self.username:
-            self.username = raw_input('login:')
+            self.username = input('login:')
             # to be used with gforge tools only. not with scp tht is currently used.
             # if not self.password:
             #    self.password = raw_input('password:')
 
     def run(self):
         """.. todo:: fix this code so that gforge proxy and scp are not both used."""
-        print """
+        print("""
                 Warning: this option (sphinx_upload) will use the scp command to copy
                 the documentation on the gforge. Be sure to have the right to do so.
                 Requires to copy your ssh key on the server !
-               """
-        print "Copying files on the GForge. Be patient ..."
+               """)
+        print("Copying files on the GForge. Be patient ...")
 
         self.test_and_build_dir()
         for output in ['html', 'latex']:
@@ -1281,27 +1310,27 @@ class upload_sphinx(Command):
                   direc,
                   direc)
 
-        print cmd1
+        print(cmd1)
         status = subprocess.call(cmd1, stdout=open('/tmp/test', 'w'),
                                  stderr=None, shell=True)
         if status != 0:
-            print 'This command failed'
+            print('This command failed')
             import sys
             sys.exit(status)
-        print "Ensured directory exists."
+        print("Ensured directory exists.")
 
     def upload_file(self, command):
-        print "Project: ", self.project
-        print "Package: ", self.package
-        print "Release: ", self.release
-        print command
+        print("Project: ", self.project)
+        print("Package: ", self.package)
+        print("Release: ", self.release)
+        print(command)
         status = subprocess.call(command, stdout=open('/tmp/test', 'w'),
                                  stderr=None, shell=True)
         if status != 0:
-            print 'This command failed'
+            print('This command failed')
             import sys
             # sys.exit(status)
-        print "Files uploaded."
+        print("Files uploaded.")
 
 
 class alea_upload(Command):
@@ -1348,7 +1377,7 @@ class alea_upload(Command):
             rc = os.path.join(os.environ['HOME'], '.pypirc')
             if os.path.exists(rc):
                 self.announce('Using PyPI login from %s' % rc)
-                config = ConfigParser.ConfigParser({
+                config = configparser.ConfigParser({
                     'username': '',
                     'password': '',
                     'repository': ''})
@@ -1365,9 +1394,9 @@ class alea_upload(Command):
             raise DistutilsOptionError(
                 "No dist file created in earlier command")
 
-        import gforge
+        from . import gforge
 
-        print "Login...."
+        print("Login....")
         server = gforge.GForgeProxy()
 
         server.login(self.username, self.password)
@@ -1387,15 +1416,15 @@ class alea_upload(Command):
         for command, pyversion, filename in self.distribution.dist_files:
             self.upload_file(server, command, pyversion, filename)
 
-        print "Logout..."
+        print("Logout...")
         server.logout()
 
     def upload_file(self, server, command, pyversion, filename):
 
-        print "Project: ", self.project
-        print "Package: ", self.package
-        print "Release: ", self.release
-        print "Filename: ", filename
+        print("Project: ", self.project)
+        print("Package: ", self.package)
+        print("Release: ", self.release)
+        print("Filename: ", filename)
 
         server.add_file(self.project, self.package, self.release, filename)
 
@@ -1413,16 +1442,16 @@ class clean(old_clean):
 
         # Test if Sconstruct is present
         if os.path.isfile('SConstruct'):
-            print 'Found an SConstruct file. Starting "scons -c" command'
+            print('Found an SConstruct file. Starting "scons -c" command')
             # Call scons -c: see the scons command#
             try:
                 os.system('scons -c')
             except:
-                print 'Failed to launch sconc -c'
+                print('Failed to launch sconc -c')
         else:
-            print 'No SConstruct found. Skipping "scons -c" command.'
+            print('No SConstruct found. Skipping "scons -c" command.')
 
         if self.all:
             for egginfo in glob.glob(pj("src", "*.egg-info")):
-                print "removing", egginfo
+                print("removing", egginfo)
                 shutil.rmtree(egginfo)
diff --git a/src/openalea/deploy/doc_tools.py b/src/openalea/deploy/doc_tools.py
index 43e635c..79d4728 100644
--- a/src/openalea/deploy/doc_tools.py
+++ b/src/openalea/deploy/doc_tools.py
@@ -20,7 +20,8 @@
 __license__ = "Cecill-C"
 __revision__ = " $Id:$"
 
-from os import remove, tmpnam
+from os import remove
+import tempfile
 
 
 def execfile_partial(local_vars, filename,
@@ -61,15 +62,14 @@ def execfile_partial(local_vars, filename,
             end_ind += 1
 
     # write tmp file
-    tmp = "%s.tmp" % tmpnam()
-    f = open(tmp, 'w')
+    f = tempfile.TemporaryFile('w')
     for line in lines[start_ind:end_ind]:
         f.write(line)
 
     f.close()
 
     # execfile
-    execfile(tmp, local_vars)
+    exec(compile(open(tmp).read(), tmp, 'exec'), local_vars)
 
     # clean file
     remove(tmp)
diff --git a/src/openalea/deploy/environ_var.py b/src/openalea/deploy/environ_var.py
index b1a79a1..9d5cf37 100644
--- a/src/openalea/deploy/environ_var.py
+++ b/src/openalea/deploy/environ_var.py
@@ -24,20 +24,7 @@ import os
 import sys
 from openalea.deploy.util import is_conda_env
 
-def set_lsb_env(name, vars):
-    """
-    Write a sh script in /etc/profile.d which set some environment variable
-    LIBRARY_PATH and PATH are processed in order to avoid overwriting
-
-    :param name: file name string without extension
-    :param vars: ['VAR1=VAL1', 'VAR2=VAL2', 'LIBRARY_PATH=SOMEPATH']
-    """
-    if is_conda_env():
-        return
-
-    if (not 'posix' in os.name):
-        return
-
+def get_posix_activate_export_str(vars):
     # Build string
     exportstr = "############ Configuration ############\n\n"
 
@@ -63,6 +50,82 @@ def set_lsb_env(name, vars):
             exportstr += 'export %s=%s\n\n' % (vname, value)
 
     exportstr += "############ Configuration END ########"
+    return exportstr
+
+def get_posix_deactivate_export_str(vars):
+    # Build string
+    exportstr = "############ Configuration ############\n\n"
+
+    for newvar in vars:
+
+        vname, value = newvar.split('=')
+
+        # Exception
+        lib_names = ['LD_LIBRARY_PATH', 'DYLD_FALLBACK_LIBRARY_PATH',
+                     'DYLD_FRAMEWORK_PATH','PATH']
+        if (vname in lib_names):
+            continue
+        else:
+            exportstr += 'unset  %s\n' % vname
+
+
+    exportstr += "############ Configuration END ########"
+    return exportstr
+
+def get_win32_activate_export_str(vars):
+    # Build string
+    exportstr = "############ Configuration ############\n\n"
+
+    for newvar in vars:
+
+        vname, value = newvar.split('=')
+
+        if ((vname == "PATH") and value):
+            exportstr += 'if [ -z "$%s" ]; then\n' % (vname)
+            exportstr += '  export %s=%s\n' % (vname, value,)
+            exportstr += 'else\n'
+            exportstr += '   export %s=%s:$%s\n' % (vname, value, vname,)
+            exportstr += 'fi\n\n'
+
+        elif (vname and value):
+            exportstr += 'export %s=%s\n\n' % (vname, value)
+
+    exportstr += "############ Configuration END ########"
+    return exportstr
+
+def get_win32_deactivate_export_str(vars):
+    # Build string
+    exportstr = "############ Configuration ############\n\n"
+
+    for newvar in vars:
+
+        vname, value = newvar.split('=')
+
+        if (vname == "PATH"):
+            continue
+        else:
+            exportstr += 'set  %s=\n' % vname
+
+
+    exportstr += "############ Configuration END ########"
+    return exportstr
+
+
+def set_lsb_env(name, vars):
+    """
+    Write a sh script in /etc/profile.d which set some environment variable
+    LIBRARY_PATH and PATH are processed in order to avoid overwriting
+
+    :param name: file name string without extension
+    :param vars: ['VAR1=VAL1', 'VAR2=VAL2', 'LIBRARY_PATH=SOMEPATH']
+    """
+    if is_conda_env():
+        return set_conda_env(vars, name)
+
+    if (not 'posix' in os.name):
+        return
+
+    exportstr = get_posix_activate_export_str(vars)
 
     try:
         filename = '/etc/profile.d/' + name + '.sh'
@@ -74,8 +137,8 @@ def set_lsb_env(name, vars):
         else:
             filename = os.path.join(os.path.expanduser('~'), ".bashrc")
 
-        print "Warning : Cannot create /etc/profile.d/%s.sh" % (name)
-        print "Trying to setup environment in %s" % filename
+        print("Warning : Cannot create /etc/profile.d/%s.sh" % (name))
+        print("Trying to setup environment in %s" % filename)
 
         # If profile.d directory is not writable, try to update $HOM/.bashrc
         try:
@@ -106,11 +169,11 @@ def set_lsb_env(name, vars):
             filename = os.path.join(os.path.expanduser('~'), script_name)
             filehandle = open(filename, 'w')
 
-        except Exception, e:
-            print e
+        except Exception as e:
+            print(e)
             raise
 
-    print "Creating %s" % (filename,)
+    print("Creating %s" % (filename,))
 
     filehandle.write(exportstr)
 
@@ -118,8 +181,8 @@ def set_lsb_env(name, vars):
     # cmdstr = "(echo $SHELL|grep bash>/dev/null)&&. %s
     # ||source %s"%(filename,filename)
     cmdstr = ". %s" % (filename,)
-    print "To enable new OpenAlea config, open a new shell or type"
-    print '  $ %s' % (bashrc_cmd)
+    print("To enable new OpenAlea config, open a new shell or type")
+    print('  $ %s' % (bashrc_cmd))
 
 
 def set_win_env(vars):
@@ -128,6 +191,8 @@ def set_win_env(vars):
 
     :param vars: ['VAR1=VAL1', 'VAR2=VAL2', 'PATH=SOMEPATH']
     """
+    if is_conda_env():
+        return set_conda_env(vars)
 
     if (not 'win32' in sys.platform):
         return
@@ -136,27 +201,30 @@ def set_win_env(vars):
 
         from string import find
         try:
-            import _winreg
-        except ImportError, e:
-            print "!!ERROR: Can not access to Windows registry."
+            if sys.version_info.major == 2:
+                import _winreg as winreg
+            else:
+                import winreg
+        except ImportError as e:
+            print("!!ERROR: Can not access to Windows registry.")
             return
 
         def queryValue(qkey, qname):
-            qvalue, type_id = _winreg.QueryValueEx(qkey, qname)
+            qvalue, type_id = winreg.QueryValueEx(qkey, qname)
             return qvalue
 
         name, value = newvar.split('=')
 
         regpath = r'SYSTEM\CurrentControlSet\Control\Session Manager\Environment'
-        reg = _winreg.ConnectRegistry(None, _winreg.HKEY_LOCAL_MACHINE)
+        reg = winreg.ConnectRegistry(None, winreg.HKEY_LOCAL_MACHINE)
         try:
-            key = _winreg.OpenKey(reg, regpath, 0, _winreg.KEY_ALL_ACCESS)
-        except  WindowsError, we:
-            print "Cannot set "+repr(name)+" for all users. Set for current user."
-            _winreg.CloseKey(reg)
+            key = winreg.OpenKey(reg, regpath, 0, winreg.KEY_ALL_ACCESS)
+        except  WindowsError as we:
+            print("Cannot set "+repr(name)+" for all users. Set for current user.")
+            winreg.CloseKey(reg)
             regpath = r'Environment'
-            reg = _winreg.ConnectRegistry(None, _winreg.HKEY_CURRENT_USER)
-            key = _winreg.OpenKey(reg, regpath, 0, _winreg.KEY_ALL_ACCESS)
+            reg = winreg.ConnectRegistry(None, winreg.HKEY_CURRENT_USER)
+            key = winreg.OpenKey(reg, regpath, 0, winreg.KEY_ALL_ACCESS)
 
         # Specific treatment for PATH variable
         if name.upper() == 'PATH':
@@ -164,34 +232,34 @@ def set_win_env(vars):
             try:
                 actualpath = queryValue(key, name)
             except:
-                print 'No PATH variable found'
+                print('No PATH variable found')
                 actualpath = ''
 
             listpath = actualpath.split(';')
             if not (value in listpath):
                 value = actualpath + ';' + value
-                print "ADD %s to PATH" % (value,)
+                print("ADD %s to PATH" % (value,))
             else:
                 value = actualpath
 
             # TEST SIZE
             if (len(value) >= 8191):
-                print "!!ERROR!! : PATH variable cannot contain more than 8191 characters"
-                print "!!ERROR!! : Please : remove unused value in your environement"
+                print("!!ERROR!! : PATH variable cannot contain more than 8191 characters")
+                print("!!ERROR!! : Please : remove unused value in your environement")
                 value = actualpath
 
         if (name and value):
 
-            expand = _winreg.REG_SZ
+            expand = winreg.REG_SZ
             # Expand variable if necessary
             if ("%" in value):
-                expand = _winreg.REG_EXPAND_SZ
+                expand = winreg.REG_EXPAND_SZ
 
-            _winreg.SetValueEx(key, name, 0, expand, value)
+            winreg.SetValueEx(key, name, 0, expand, value)
             # os.environ[name] = value #not necessary
 
-        _winreg.CloseKey(key)
-        _winreg.CloseKey(reg)
+        winreg.CloseKey(key)
+        winreg.CloseKey(reg)
 
     # Refresh Environment
     try:
@@ -205,7 +273,64 @@ def set_win_env(vars):
                                                  WM_SETTINGCHANGE, 0, sParam,
                                                  SMTO_ABORTIFHUNG, 100)
         if not res1:
-            print ("result %s, %s from SendMessageTimeout" % (bool(res1), res2))
+            print("result %s, %s from SendMessageTimeout" % (bool(res1), res2))
+
+    except Exception as e:
+        print(e)
+
+
 
-    except Exception, e:
-        print e
+def set_conda_env(vars, name = 'openalea'):
+    """
+    Set conda environment variable persistently.
+    Use method proposed in https://conda.io/docs/user-guide/tasks/manage-environments.html#saving-environment-variables
+
+    :param vars: ['VAR1=VAL1', 'VAR2=VAL2', 'PATH=SOMEPATH']
+
+    """
+    envprefix = conda_prefix()
+
+    from os.path import join, exists
+    from os import makedirs
+    activate_env_vars_dir = join(envprefix, 'etc', 'conda', 'activate.d')
+    deactivate_env_vars_dir = join(envprefix, 'etc', 'conda', 'deactivate.d')
+
+    if not exists(activate_env_vars_dir):
+        makedirs(activate_env_vars_dir)
+
+    if not exists(activate_env_vars_dir):
+        makedirs(deactivate_env_vars_dir)
+
+    if ('posix' in os.name) :
+        filename = join(activate_env_vars_dir, name+'.sh')
+        config = file(filename,'w')
+        config.write('#!/bin/sh\n\n')
+        config.write(get_posix_activate_export_str(vars))
+        config.close()
+
+        filename2 = join(deactivate_env_vars_dir, name+'.sh')
+        config = file(filename2,'w')
+        config.write('#!/bin/sh\n\n')
+        config.write(get_posix_activate_export_str(vars))
+        config.close()
+
+    else:
+        filename = join(activate_env_vars_dir, name+'.bat')
+        config = file(filename,'w')
+        config.write(get_win32_activate_export_str(vars))
+        config.close()
+
+        filename2 = join(deactivate_env_vars_dir, name+'.bat')
+        config = file(filename2,'w')
+        config.write(get_win32_deactivate_export_str(vars))
+        config.close()
+    
+    print("Creating %s and %s" % (repr(filename),repr(filename2)))
+
+    if ('posix' in os.name) :
+        bashrc_cmd = "source %s" % (filename,)
+    else:
+        bashrc_cmd = "call %s" % (filename,)
+        
+    print("To enable new OpenAlea config, open a new shell or type")
+    print('  $ %s' % (bashrc_cmd))
diff --git a/src/openalea/deploy/gforge.py b/src/openalea/deploy/gforge.py
index ba7d95e..b33291f 100644
--- a/src/openalea/deploy/gforge.py
+++ b/src/openalea/deploy/gforge.py
@@ -59,7 +59,7 @@ class GForgeProxy(object):
 
     def login(self, userid=None, passwd=None):
         """  Open a session """
-        import gforge_util
+        from . import gforge_util
         rc_userid, rc_passwd = gforge_util.find_login_passwd()
         userid = userid or rc_userid
         passwd = passwd or rc_passwd
@@ -69,8 +69,8 @@ class GForgeProxy(object):
             self.userid = userid
             self.passwd = passwd
 
-        except Exception, e:
-            print e
+        except Exception as e:
+            print(e)
 
             return self.session
 
@@ -193,8 +193,8 @@ class GForgeProxy(object):
 
                     return (name, date, notes, changes)
 
-        except Exception, e:
-            print e
+        except Exception as e:
+            print(e)
         
         return (None, None, None, None,)
 
@@ -323,8 +323,8 @@ class GForgeProxy(object):
         try:
             return self.server.addPackage(self.session,
                                           project_id, package_name, int(public))
-        except Exception, e:
-            print e
+        except Exception as e:
+            print(e)
 
     def add_release(self, project_id, package_id, release_name,
                     notes, changes):
@@ -339,8 +339,8 @@ class GForgeProxy(object):
         try:
             return self.server.addRelease(self.session, project_id, package_id,
                                           release_name, notes, changes)
-        except Exception, e:
-            print e
+        except Exception as e:
+            print(e)
 
     def add_big_file(self, project_id, package_id, release_id, filename,
                      proc_type="any", file_type="other"):
@@ -360,18 +360,18 @@ class GForgeProxy(object):
         type = type_id.get(file_type, type_id['other'])
         processor = proc_id.get(proc_type, proc_id['any'])
 
-        print "Uploading %s..." % (name,)
+        print("Uploading %s..." % (name,))
 
         try:
-            import gforge_util
+            from . import gforge_util
             gforge_util.gforge_login(self.userid, self.passwd)
             gforge_util.upload_file(filename, project_id, package_id,
                                     release_id, type, processor)
 
-            print "Done."
+            print("Done.")
 
-        except Exception, e:
-            print e
+        except Exception as e:
+            print(e)
 
     def add_file(self, project_id, package_id, release_id, filename,
                  proc_type="any", file_type="other"):
@@ -399,7 +399,7 @@ class GForgeProxy(object):
 
         release_time = int(time.mktime(time.localtime()))
 
-        print "Uploading %s..." % (name,),
+        print("Uploading %s..." % (name,))
 
         try:
             
@@ -407,10 +407,10 @@ class GForgeProxy(object):
                                       _release_id,
                                       name, filestr, type, processor,
                                       release_time)
-            print "Done."
+            print("Done.")
             return ret
         
-        except Exception, e:
+        except Exception as e:
             return self.add_big_file(project_id, package_id, release_id,
                                      filename, proc_type, file_type)
 
@@ -422,7 +422,7 @@ class GForgeProxy(object):
         project_id, package_id = \
             self.convert_to_id(project_id, package_id)
 
-        import gforge_util
+        from . import gforge_util
         gforge_util.gforge_login(self.userid, self.passwd)
         gforge_util.delete_package(project_id, package_id)
 
@@ -434,7 +434,7 @@ class GForgeProxy(object):
         project_id, package_id, release_id = \
             self.convert_to_id(project_id, package_id, release_id)
 
-        import gforge_util
+        from . import gforge_util
         gforge_util.gforge_login(self.userid, self.passwd)
         gforge_util.delete_release(project_id, package_id, release_id)
 
@@ -443,11 +443,11 @@ class GForgeProxy(object):
         project_id, package_id, release_id, file_id = \
             self.convert_to_id(project_id, package_id, release_id, file_id)
         
-        import gforge_util
+        from . import gforge_util
         gforge_util.gforge_login(self.userid, self.passwd)
-        print 'Trying to delete file %s' % file_id,
+        print('Trying to delete file %s' % file_id)
         gforge_util.delete_file(project_id, package_id, release_id, file_id)
-        print 'Done.'
+        print('Done.')
 
 
 # CONST
diff --git a/src/openalea/deploy/gforge_util.py b/src/openalea/deploy/gforge_util.py
index fa978e5..abd28f2 100644
--- a/src/openalea/deploy/gforge_util.py
+++ b/src/openalea/deploy/gforge_util.py
@@ -42,11 +42,17 @@ then uploads it to the W3C validator.
 __license__ = "Cecill-C"
 __revision__ = " $Id$ "
 
-import urllib
-import urllib2
+
+try:
+    # python 3
+    from urllib.request import BaseHandler, HTTPHandler
+except:
+    # python 2
+    from urllib2 import BaseHandler, HTTPHandler
+
 import mimetools, mimetypes
 import os, stat, sys
-from cStringIO import StringIO
+from io import StringIO
 
 
 class Callable:
@@ -61,9 +67,9 @@ class Callable:
 doseq = 1
 
 
-class MultipartPostHandler(urllib2.BaseHandler):
+class MultipartPostHandler(BaseHandler):
     """ todo """
-    handler_order = urllib2.HTTPHandler.handler_order - 10  # needs to run first
+    handler_order = HTTPHandler.handler_order - 10  # needs to run first
 
     def http_request(self, request):
         data = request.get_data()
@@ -78,10 +84,10 @@ class MultipartPostHandler(urllib2.BaseHandler):
                         v_vars.append((key, value))
             except TypeError:
                 systype, value, traceback = sys.exc_info()
-                raise TypeError, "not a valid non-string sequence or mapping object", traceback
+                raise TypeError("not a valid non-string sequence or mapping object").with_traceback(traceback)
 
             if len(v_files) == 0:
-                data = urllib.urlencode(v_vars, doseq)
+                data = urllib.parse.urlencode(v_vars, doseq)
             else:
                 boundary, data = self.multipart_encode(v_vars, v_files)
 
@@ -89,8 +95,8 @@ class MultipartPostHandler(urllib2.BaseHandler):
                 if (request.has_header('Content-Type')
                     and request.get_header('Content-Type').find(
                         'multipart/form-data') != 0):
-                    print "Replacing %s with %s" % (
-                    request.get_header('content-type'), 'multipart/form-data')
+                    print("Replacing %s with %s" % (
+                    request.get_header('content-type'), 'multipart/form-data'))
                 request.add_unredirected_header('Content-Type', contenttype)
 
             request.add_data(data)
@@ -135,11 +141,15 @@ class MultipartPostHandler(urllib2.BaseHandler):
 
 ##########################################################"
 
-import cookielib, urllib, urllib2, urlparse
 import os
 from os.path import join as pj, exists
 import glob
-import ConfigParser
+try :
+    # python 3
+    import configparser
+except:
+    # python 2
+    import ConfigParser as configparser
 import getpass
 
 urlOpener = None
@@ -148,10 +158,10 @@ urlOpener = None
 def find_login_passwd(allow_user_input=True):
     home = ""
     # Get password
-    if os.environ.has_key('USERPROFILE'):
+    if 'USERPROFILE' in os.environ:
         home = os.environ['USERPROFILE']
 
-    elif os.environ.has_key('HOME'):
+    elif 'HOME' in os.environ:
         home = os.environ['HOME']
 
     rc = pj(home, '.pypirc')
@@ -162,8 +172,8 @@ def find_login_passwd(allow_user_input=True):
 
     username, password = None, None
     if exists(rc):
-        print 'Using PyPI login from %s' % (rc)
-        config = ConfigParser.ConfigParser({
+        print('Using PyPI login from %s' % (rc))
+        config = configparser.ConfigParser({
             'username': '',
             'password': '',
             'repository': ''})
@@ -172,10 +182,25 @@ def find_login_passwd(allow_user_input=True):
         username = config.get('server-login', 'username')
         password = config.get('server-login', 'password')
     elif allow_user_input:
-        username = raw_input("Enter your GForge login:")
+        username = input("Enter your GForge login:")
         password = getpass.getpass("Enter you GForge password:")
     return username, password
 
+try:
+    # python 3
+    from urllib.parse import urlencode, urlparse, splituser, unquote, urlunparse
+    from urllib.request import build_opener, install_opener, HTTPCookieProcessor, Request, urlopen
+except:
+    # python 2
+    from urllib2 import build_opener, install_opener, HTTPCookieProcessor, Request, splituser, unquote, urlopen
+    from urllib import urlencode
+    from urlparse import urlparse, urlunparse
+
+try:
+    import http.cookiejar as cookiejar
+except:
+    import cookielib as cookiejar
+
 
 def cookie_login(loginurl, values):
     """ Open a session
@@ -185,23 +210,21 @@ def cookie_login(loginurl, values):
     """
     global urlOpener
     # Enable cookie support for urllib2
-    cookiejar = cookielib.CookieJar()
-    urlOpener = urllib2.build_opener(urllib2.HTTPCookieProcessor(cookiejar),
-                                     MultipartPostHandler)
+    mcookiejar = cookiejar.CookieJar()
+    urlOpener = build_opener(HTTPCookieProcessor(mcookiejar), MultipartPostHandler)
     
-    data = urllib.urlencode(values)
-    request = urllib2.Request(loginurl, data)
-    url = urlOpener.open(
-        request)  # Our cookiejar automatically receives the cookies
-    urllib2.install_opener(urlOpener)
+    data = urlencode(values)
+    request = Request(loginurl, data)
+    url = urlOpener.open(request)  # Our mcookiejar automatically receives the cookies
+    urllib.request.install_opener(urlOpener)
 
     # Make sure we are logged in by checking the presence of the cookie "session_ser".
     # (which is the cookie containing the session identifier.)
-    if not 'session_ser' in [cookie.name for cookie in cookiejar]:
-        print "Login failed !"
+    if not 'session_ser' in [cookie.name for cookie in mcookiejar]:
+        print("Login failed !")
         return False
     else:
-        print "We are logged in !"
+        print("We are logged in !")
         return True
 
 
@@ -298,36 +321,36 @@ def add_private_gforge_repositories(userid=None, passwd=None):
         setuptools.package_index.open_with_auth = open_with_auth2
 
 
+
 def open_with_auth2(url):
     """
     Open a urllib2 request, handling HTTP authentication
     In this version, user-agent is ignored
     """
 
-    scheme, netloc, path, params, query, frag = urlparse.urlparse(url)
+    scheme, netloc, path, params, query, frag = urlparse(url)
 
     if scheme in ('http', 'https'):
-        auth, host = urllib2.splituser(netloc)
+        auth, host = splituser(netloc)
     else:
         auth = None
 
     if auth:
-        auth = "Basic " + urllib2.unquote(auth).encode('base64').strip()
-        new_url = urlparse.urlunparse((scheme, host, path, params, query, frag))
-        request = urllib2.Request(new_url)
+        auth = "Basic " + unquote(auth).encode('base64').strip()
+        new_url = urlunparse((scheme, host, path, params, query, frag))
+        request = Request(new_url)
         request.add_header("Authorization", auth)
     else:
-        request = urllib2.Request(url)
+        request = Request(url)
 
     # request.add_header('User-Agent', user_agent)
-    fp = urllib2.urlopen(request)
+    fp = urlopen(request)
 
     if auth:
         # Put authentication info back into request URL if same host,
         # so that links found on the page will work
-        s2, h2, path2, param2, query2, frag2 = urlparse.urlparse(fp.url)
+        s2, h2, path2, param2, query2, frag2 = urlparse(fp.url)
         if s2 == scheme and h2 == host:
-            fp.url = urlparse.urlunparse(
-                (s2, netloc, path2, param2, query2, frag2))
+            fp.url = urlunparse((s2, netloc, path2, param2, query2, frag2))
 
     return fp
diff --git a/src/openalea/deploy/install_lib.py b/src/openalea/deploy/install_lib.py
index ac79d89..7305641 100644
--- a/src/openalea/deploy/install_lib.py
+++ b/src/openalea/deploy/install_lib.py
@@ -3,7 +3,7 @@
 #
 #       OpenAlea.Deploy : OpenAlea setuptools extension
 #
-#       Copyright 2006-2015 INRIA - CIRAD - INRA
+#       Copyright 2006-2017 INRIA - CIRAD - INRA
 #
 #       File author(s): Samuel Dufour-Kowalski <samuel.dufour@sophia.inria.fr>
 #                       Christophe Pradal <christophe.prada@cirad.fr>
@@ -31,11 +31,20 @@ from os.path import join
 
 
 from openalea.deploy.util import get_all_lib_dirs, get_base_dir, INSTALL_DIST
-from openalea.deploy.util import is_virtual_env, is_conda_env
+from openalea.deploy.util import is_virtual_env, is_conda_env, conda_prefix
 from distutils.dir_util import mkpath
 from distutils.sysconfig import get_python_lib
 
 
+def get_conda_dyn_lib():
+    """ Return the path for dynamic library in conda environment """
+    env_dir = conda_prefix()
+    if ("posix" in os.name):
+        dyn_dir = os.path.join(env_dir, 'lib')
+    else : # Windows
+        dyn_dir = os.path.join(env_dir, 'Library', 'lib')
+    return dyn_dir
+
 def get_default_dyn_lib():
     """Return the default path for dynamic library."""
     basedir = get_python_lib()
@@ -50,9 +59,7 @@ def get_default_dyn_lib():
 
     # Conda environment
     if is_conda_env():
-        env_dir = os.path.abspath(os.environ['PREFIX'])
-        dyn_dir = os.path.join(env_dir, 'lib')
-        return dyn_dir
+        return get_conda_dyn_lib()
 
     # Standard environment
     if ("posix" in os.name):
@@ -76,7 +83,7 @@ def get_dyn_lib_dir(use_default=True):
     try:
         f = open(join(up_dir, "shared-lib.pth"), 'r')
         lib_dir = f.read()
-        print 'Reading shared-lib.pth found in %s' % lib_dir
+        print('Reading shared-lib.pth found in %s' % lib_dir)
         f.close()
 
     except Exception:
@@ -100,8 +107,8 @@ def set_dyn_lib_dir(path):
         f = open(dst, 'w')
         f.write(path)
         f.close()
-    except Exception, e:
-        print e
+    except Exception as e:
+        print(e)
 
 
 def is_lib(filename):
@@ -117,6 +124,7 @@ def is_lib(filename):
     for pat in (".dll", ".so", ".a", ".lib", ".dylib", ".la", ".framework"):
         if filename.endswith(pat):
             return True
+
     # Add linux libraries lib.so.1.3.4
     if '.so.' in filename:
         try:
@@ -156,7 +164,7 @@ def link_lib(src, dst):
         pass
 
     # copy
-    print "Installing %s -> %s" % (src, dst)
+    print("Installing %s -> %s" % (src, dst))
     if (os.path.exists(dst)):
         os.unlink(dst)
 
@@ -166,7 +174,7 @@ def link_lib(src, dst):
         shutil.copy2(src, dst)
 
     # create an egm file
-    print "Installing ", mark_file
+    print("Installing ", mark_file)
     f = open(mark_file, 'w')
     f.write(src)
     f.close()
@@ -188,16 +196,16 @@ def clean_lib(lib_dir, clean_all=False):
             libfile = egm[:- len(EGG_MARKER_EXTENSION)]
 
             try:
-                print "Removing ", libfile
+                print("Removing ", libfile)
                 os.remove(libfile)
-            except Exception, e:
-                print "Cannot remove %s : %s" % (libfile, e)
+            except Exception as e:
+                print("Cannot remove %s : %s" % (libfile, e))
 
             try:
-                print "Removing ", egm
+                print("Removing ", egm)
                 os.remove(egm)
-            except Exception, e:
-                print "Cannot remove %s : %s" % (egm, e)
+            except Exception as e:
+                print("Cannot remove %s : %s" % (egm, e))
 
 
 def install_lib(lib_dir):
@@ -208,13 +216,8 @@ def install_lib(lib_dir):
     """
 
     # Conda environment
-    if is_conda_env():
-        if 'CONDA_BUILD' in os.environ:
-            env_dir = os.path.abspath(os.environ['PREFIX'])
-        else:
-            env_dir = os.path.abspath(os.environ['CONDA_PREFIX'])
-        dyn_dir = os.path.join(env_dir, 'lib')
-        return dyn_dir
+    #if is_conda_env():
+    #    return get_conda_dyn_lib()
 
     if not lib_dir:
         lib_dir = get_dyn_lib_dir()
@@ -240,7 +243,6 @@ def install_lib(lib_dir):
 
     # install lib
     for d in egglibdirs:
-
         try:
             src_dir = os.path.abspath(d)
             dst_dir = os.path.abspath(lib_dir)
@@ -252,7 +254,7 @@ def install_lib(lib_dir):
                     dst = join(dst_dir, f)
                     link_lib(src, dst)
 
-        except Exception, e:
-            print e
+        except Exception as e:
+            print(e)
 
     return lib_dir
diff --git a/src/openalea/deploy/metainfo.py b/src/openalea/deploy/metainfo.py
index f8bf32c..9e0315b 100644
--- a/src/openalea/deploy/metainfo.py
+++ b/src/openalea/deploy/metainfo.py
@@ -33,9 +33,13 @@ def read_metainfo(filename, section='metainfo', verbose=False):
         nocolor()
 
     if verbose:
-        print green('Reading metainfo ')
-    import ConfigParser
-    config = ConfigParser.RawConfigParser()
+        print(green('Reading metainfo '))
+    try:
+        import configparser
+    except:
+        import ConfigParser as configparser
+
+    config = configparser.RawConfigParser()
     res = config.read(filename)
     if len(res) == 0:
         raise IOError("Input file %s does not seem to exist" % filename)
@@ -44,10 +48,10 @@ def read_metainfo(filename, section='metainfo', verbose=False):
 
     for option in config.options(section):
         if verbose:
-            print green('...%s: %s' % (option, config.get(section, option)))
+            print(green('...%s: %s' % (option, config.get(section, option))))
         metadata[option] = config.get(section, option)
 
-    if 'project' in metadata.keys():
+    if 'project' in list(metadata.keys()):
         if metadata['project'] not in ['vplants', 'openalea', 'alinea']:
             raise ValueError(
                 'option project (openalea/vplants/alinea) not found in metainfo.ini file')
@@ -56,7 +60,7 @@ def read_metainfo(filename, section='metainfo', verbose=False):
             'option project (openalea/vplants/alinea) not found in metainfo.ini file')
 
     for word in compulsary_words:
-        if word not in metadata.keys():
+        if word not in list(metadata.keys()):
             raise ValueError('%s field not found in metainfo.ini' % word)
 
     return metadata
diff --git a/src/openalea/deploy/shared_data.py b/src/openalea/deploy/shared_data.py
index 5ebdc21..54f6bb9 100644
--- a/src/openalea/deploy/shared_data.py
+++ b/src/openalea/deploy/shared_data.py
@@ -2,14 +2,14 @@
 #
 #       OpenAlea.Deploy: OpenAlea setuptools extension
 #
-#       Copyright 2008 INRIA - CIRAD - INRA  
+#       Copyright 2008 INRIA - CIRAD - INRA
 #
 #       File author(s): Thomas Cokelae
 #
 #       Distributed under the Cecill-C License.
 #       See accompanying file LICENSE.txt or copy at
 #           http://www.cecill.info/licences/Licence_CeCILL-C_V1-en.html
-# 
+#
 #       OpenAlea WebSite : http://openalea.gforge.inria.fr
 #
 
@@ -17,9 +17,19 @@
 
 """
 import types
+import os
 from os.path import join as pj
 from os.path import realpath, isdir, isfile
-from openalea.core.path import path
+try:
+    from path import Path
+except ImportError:
+    try:
+        from path import path as Path
+    except ImportError:
+        try:
+            from openalea.core.path import path as Path
+        except ImportError:
+            from IPython.external.path import path as Path
 
 __license__ = "Cecill-C"
 __revision__ = " $Id: gforge.py 2243 2010-02-08 17:08:47Z cokelaer $ "
@@ -32,28 +42,28 @@ def shared_data(package_path, filename=None, pattern=None,
     """Return a valid pathname pointing to a shared-data directory or a shared-data file.
 
     :Parameters:
-        - `package_path` (str or list) - Can be either a string representing a package path or a list of package paths. (e.g. 
+        - `package_path` (str or list) - Can be either a string representing a package path or a list of package paths. (e.g.
         :py:class:`path`('/home/user/openalea/deploy/src/openalea/deploy') or [:py:class:`path`('/usr/lib/pymodules/python2.7/numpy')]).
         If package_path is a list, then the first element of package_path is used.
         - `filename` (str) - An optional valid filename without any path that is expected
         to be found in :py:obj:`share_path`.
-        - `share_path` (str) - The path where the share data directory is expected to be found. 
-        The default value is :py:const:`.share_path`. Important: All users should keep this 
+        - `share_path` (str) - The path where the share data directory is expected to be found.
+        The default value is :py:const:`.share_path`. Important: All users should keep this
         default value in order to ease the share of data between the different packages.
 
-    :Returns: 
-        a valid directory path if filename is not provided, and a valid file path to 
-        filename (including filename) otherwise. The directory or file is searched firstly into  
+    :Returns:
+        a valid directory path if filename is not provided, and a valid file path to
+        filename (including filename) otherwise. The directory or file is searched firstly into
         ':py:obj:`package_path`, then into ':py:obj:`package_path` parent directory, then
         into ':py:obj:`package_path` parent parent directory, and so on, going up until the parent parent
-        directory of the last Python package found.  
+        directory of the last Python package found.
         If no valid path is found, returns None.
-        
+
     :Returns Type:
         str
-       
-    :Examples: 
-    
+
+    :Examples:
+
     >>> shared_data(['/home/user/mypackage'])
     '/home/user/mypackage/share/data'
     >>> shared_data('/home/user/mypackage', 'my_file.csv')
@@ -64,7 +74,7 @@ def shared_data(package_path, filename=None, pattern=None,
     >>> shared_data(mypackage, pattern='*.mtg')
     ['/home/user/mypackage/share/databases/mtg1.mtg', ...]
     """
-    
+
     if isinstance(package_path, types.ModuleType):
         package_path = package_path.__path__
 
@@ -73,7 +83,7 @@ def shared_data(package_path, filename=None, pattern=None,
             return None
         else:
             package_path = package_path[0]
-    package_path = path(package_path)
+    package_path = Path(package_path)
     ff = package_path / share_path
     ff = ff.realpath()
     shared_data_path = None
@@ -96,7 +106,7 @@ def shared_data(package_path, filename=None, pattern=None,
         if shared_data_path is None:
             shared_data_path = shared_data(package_path.parent.parent, filename,
                                            pattern, share_path)
-    
+
     return shared_data_path
 
 
diff --git a/src/openalea/deploy/shortcut.py b/src/openalea/deploy/shortcut.py
index 379beda..6f16358 100644
--- a/src/openalea/deploy/shortcut.py
+++ b/src/openalea/deploy/shortcut.py
@@ -60,9 +60,9 @@ def create_win_shortcut(name, target, arguments="",
         win32dir = get_base_dir('pywin32')
         os.environ['PATH'] += ';' + os.path.join(win32dir, 'pywin32_system32')
         from win32com.shell import shell, shellcon
-    except Exception, e:
-        print e
-        print "ERROR : pywin32 is not installed. Cannot create shortcut."
+    except Exception as e:
+        print(e)
+        print("ERROR : pywin32 is not installed. Cannot create shortcut.")
         return
     
     import win32api
@@ -103,34 +103,37 @@ def set_win_reg(key, subkey, name, value):
         return
 
     try:
-        import _winreg
+        if sys.version_info.major == 2:
+            import _winreg as winreg
+        else:
+            import winreg
 
-    except ImportError, e:
-        print "!!ERROR: Can not access to Windows registry."
+    except ImportError as e:
+        print("!!ERROR: Can not access to Windows registry.")
         return
 
-    keymap = {'HKEY_CLASSES_ROOT': _winreg.HKEY_CLASSES_ROOT,
-              'HKEY_CURRENT_CONFIG': _winreg.HKEY_CURRENT_CONFIG,
-              'HKEY_CURRENT_USER': _winreg.HKEY_CURRENT_USER,
-              'HKEY_DYN_DATA': _winreg.HKEY_DYN_DATA,
-              'HKEY_LOCAL_MACHINE': _winreg.HKEY_LOCAL_MACHINE,
-              'HKEY_PERFORMANCE_DATA': _winreg.HKEY_PERFORMANCE_DATA,
-              'HKEY_USERS': _winreg.HKEY_USERS,
-              'HKCR': _winreg.HKEY_CLASSES_ROOT,
-              'HKCC': _winreg.HKEY_CURRENT_CONFIG,
-              'HKCU': _winreg.HKEY_CURRENT_USER,
-              'HKDD': _winreg.HKEY_DYN_DATA,
-              'HKLM': _winreg.HKEY_LOCAL_MACHINE,
-              'HKPD': _winreg.HKEY_PERFORMANCE_DATA,
-              'HKU': _winreg.HKEY_USERS,
+    keymap = {'HKEY_CLASSES_ROOT': winreg.HKEY_CLASSES_ROOT,
+              'HKEY_CURRENT_CONFIG': winreg.HKEY_CURRENT_CONFIG,
+              'HKEY_CURRENT_USER': winreg.HKEY_CURRENT_USER,
+              'HKEY_DYN_DATA': winreg.HKEY_DYN_DATA,
+              'HKEY_LOCAL_MACHINE': winreg.HKEY_LOCAL_MACHINE,
+              'HKEY_PERFORMANCE_DATA': winreg.HKEY_PERFORMANCE_DATA,
+              'HKEY_USERS': winreg.HKEY_USERS,
+              'HKCR': winreg.HKEY_CLASSES_ROOT,
+              'HKCC': winreg.HKEY_CURRENT_CONFIG,
+              'HKCU': winreg.HKEY_CURRENT_USER,
+              'HKDD': winreg.HKEY_DYN_DATA,
+              'HKLM': winreg.HKEY_LOCAL_MACHINE,
+              'HKPD': winreg.HKEY_PERFORMANCE_DATA,
+              'HKU': winreg.HKEY_USERS,
               }
 
     if (name):
         subkey += '/' + name
     try:
-        _winreg.SetValue(keymap[key], subkey, _winreg.REG_SZ, value)
+        winreg.SetValue(keymap[key], subkey, winreg.REG_SZ, value)
     except:
-        print "Cannot set %s/%s/%s registery key" % (key, subkey, name)
+        print("Cannot set %s/%s/%s registery key" % (key, subkey, name))
 
 
 def create_fd_shortcut(name, target, arguments="", version="",
diff --git a/src/openalea/deploy/system_dependencies/dependency.py b/src/openalea/deploy/system_dependencies/dependency.py
index 2c7b735..8613c4a 100644
--- a/src/openalea/deploy/system_dependencies/dependency.py
+++ b/src/openalea/deploy/system_dependencies/dependency.py
@@ -17,6 +17,8 @@
 ############################################################
 
 import platform, types, warnings, collections, subprocess, abc
+from six import with_metaclass
+
 
 
 __all__ =  ["get_platform"]
@@ -53,9 +55,8 @@ class MSingleton(type):
 
 
 
-class BaseOsFactory(object):
+class BaseOsFactory(with_metaclass(MSingleton,object)):
     """Base class for foactories that create objects depending on the operating system"""
-    __metaclass__ = MSingleton
 
     @classmethod
     def get_platform(cls):
@@ -136,7 +137,7 @@ class OsInterfaceFactory(BaseOsFactory):
         self.__oses[osname] = osinterface
 
     def get_platforms(self):
-        return self.__oses.keys()
+        return list(self.__oses.keys())
 
 
 
@@ -170,7 +171,7 @@ class OsInterface(object):
         command += " "+ package
 
         if fake:
-            print command
+            print(command)
         else:
             subprocess.call(command.strip().split(" "))
 
@@ -186,15 +187,15 @@ class DistributionPackageFactory(BaseOsFactory):
         self.__distPkgs = {}
 
     def register(self, cls):
-        assert isinstance(type(cls), types.TypeType)
+        assert isinstance(type(cls), type)
         name = cls.__name__
         name = name[:name.find("_PackageNames")].replace("_", " ").lower()
-        print "registering:", name
+        print("registering:", name)
         self.__distPkgs[name] = cls
 
     def create(self, platform=None, conflictSolve=lambda x: x[0]):
         assert platform is not None
-        maxIntersectionDistrib = self.intersect_and_solve(platform, self.__distPkgs.keys(), conflictSolve)
+        maxIntersectionDistrib = self.intersect_and_solve(platform, list(self.__distPkgs.keys()), conflictSolve)
         cls = self.__distPkgs.get(maxIntersectionDistrib, None)
         if cls: return cls()
 
@@ -207,9 +208,8 @@ class DistributionPackageNames(dict):
         dict.__init__(self)
         self.update(packages)
     def update(self, other):
-        ks, vs = zip(*other.iteritems())
-        other = dict(zip(ks,map(lambda x: BaseDependency(x) if isinstance(x,str) else x,
-                                vs)))
+        ks, vs = list(zip(*iter(other.items())))
+        other = dict(list(zip(ks,[BaseDependency(x) if isinstance(x,str) else x for x in vs])))
         dict.update(self, other)
 
 
@@ -269,20 +269,20 @@ class DependencySolver(object):
 
     def __str__(self):
         return "canonical->%s\ndistribution->%s\ncompensated->%s"%(str(self.__canonical_deps),
-                                                                 str(self.__translation.values()),
+                                                                 str(list(self.__translation.values())),
                                                                  str(self.other_packages()))
 
     def packages(self):
         return self.__canonical_deps
 
     def runtime_distribution_packages(self):
-        return [dep for canoDep, dep in self.__translation.iteritems() if canoDep[-4:] != "-dev"]
+        return [dep for canoDep, dep in self.__translation.items() if canoDep[-4:] != "-dev"]
 
     def development_distribution_packages(self):
-        return [dep for canoDep, dep in self.__translation.iteritems() if canoDep[-4:] == "-dev"]
+        return [dep for canoDep, dep in self.__translation.items() if canoDep[-4:] == "-dev"]
 
     def other_packages(self):
-        return [dep for canoDep, dep in self.__translation.iteritems() if not dep.is_base()]
+        return [dep for canoDep, dep in self.__translation.items() if not dep.is_base()]
 
     ############################################################
     # Dependency solving and distribution translation follows: #
@@ -305,7 +305,7 @@ class DependencySolver(object):
         while currentPkg:
             hasChilds = True
             child = None
-            try: child = currentPkgChilds.next()
+            try: child = next(currentPkgChilds)
             except: hasChilds = False
             if hasChilds:
                 ancestors.append(currentPkg)
@@ -338,7 +338,7 @@ class DependencySolver(object):
                     if pkg not in self.__dep_tree__:
                         self.__translation[pkg] = distribCls[pkg]
         else:
-            print "No decanonification"
+            print("No decanonification")
 
 
 
diff --git a/src/openalea/deploy/system_dependencies/dependency_builder.py b/src/openalea/deploy/system_dependencies/dependency_builder.py
index 13c7531..bebb09b 100644
--- a/src/openalea/deploy/system_dependencies/dependency_builder.py
+++ b/src/openalea/deploy/system_dependencies/dependency_builder.py
@@ -1,3 +1,4 @@
+from __future__ import print_function
 # -*- python -*-
 #
 #       openalea.deploy.dependency_builder
@@ -46,14 +47,17 @@ __revision__ = " $Id$ "
 
 # TODO! This can be merged with the utility that makes windows installers
 # and the system_dependecies utility.
+from  six import with_metaclass
 
 import traceback
 import platform
 import os
 import sys
 import shutil
-import urllib2
-import urllib
+
+from six.moves.urllib.request import urlopen, urlretrieve
+from six.moves.urllib.error import URLError
+
 import subprocess
 import glob
 import time
@@ -67,11 +71,12 @@ import datetime
 import zipfile
 import tarfile
 import ctypes
-import patch
-import ConfigParser #used by some project builders
+from . import patch
+import configparser #used by some project builders
 from os.path import join as pj, splitext, getsize, exists, abspath, split, dirname, realpath
 from collections import namedtuple, OrderedDict, defaultdict
 from re import compile as re_compile
+from functools import reduce
 
 #################################
 # Some Utilities - Path Joining #
@@ -153,7 +158,7 @@ def get_python_dll():
         py_path = ctypes.wstring_at(path)
     else:
         raise OSError("Couldn't determine python%d%d.dll path"%pyver)
-    return pj(py_path, u"python%d%d.dll"%pyver)
+    return pj(py_path, "python%d%d.dll"%pyver)
 
 def get_python_scripts_dirs():
     dirs = []
@@ -171,7 +176,7 @@ def get_python_scripts_dirs():
             # be compensated:
             if sys.platform == "win32":
                 # restore "driveletter:\\" on windows
-                script_path = script_path.replace(":", ":"+os.sep)            
+                script_path = script_path.replace(":", ":"+os.sep)
             else:
                 # restore "/" on unixes
                 script_path = "/"+script_path
@@ -184,7 +189,7 @@ def get_python_scripts_dirs():
 ###############################
 # Some functions to strip away html tags from html documents.
 # from http://stackoverflow.com/questions/753052/strip-html-from-strings-in-python
-from HTMLParser import HTMLParser
+from html.parser import HTMLParser
 class MLStripper(HTMLParser):
     def __init__(self):
         self.reset()
@@ -211,7 +216,7 @@ def into_subdir(base, pattern):
 def download(url, easy_name, arch_path):
     def download_reporter(bk, bksize, bytes):
         if bytes == 0:
-            raise urllib2.URLError("Url doesn't point to an existing resource.")
+            raise URLError("Url doesn't point to an existing resource.")
         progress= float(bk)/(bytes/bksize) * 100
         presentation_url = url[:]
         if len(presentation_url) >= 100:
@@ -222,7 +227,7 @@ def download(url, easy_name, arch_path):
     # get the size of the ressource we're about to download
     remote_sz = float("inf")
     try:
-        remote    = urllib.urlopen(url)
+        remote    = urlopen(url)
         # the content type shouldn' be text/*,
         # but application/*. text/* == error
         if remote.info().getheaders("Content-Type")[0].startswith("application"):
@@ -230,7 +235,7 @@ def download(url, easy_name, arch_path):
             if len(c_len):
                 remote_sz = int(remote.info().getheaders("Content-Length")[0])
             else:
-                print "Unknown content length, cannot determine if download can be skipped..."
+                print("Unknown content length, cannot determine if download can be skipped...")
                 remote_sz = float("inf")
         elif remote.info().getheaders("Content-Type")[0].startswith("text/html"):
             raise IOError( strip_tags(remote.read()) )
@@ -251,7 +256,7 @@ def download(url, easy_name, arch_path):
             raise os.error
     except os.error:
         try:
-            urllib.urlretrieve(url, arch_path, download_reporter)
+            urlretrieve(url, arch_path, download_reporter)
         except:
             traceback.print_exc()
             ret = False
@@ -260,7 +265,7 @@ def download(url, easy_name, arch_path):
 def unpack(arch, where):
     arch = arch
     base, ext = splitext( arch )
-    print "unpacking", arch
+    print("unpacking", arch)
     # TODO : verify that there is no absolute path inside zip.
     if ext == ".zip":
         zipf = zipfile.ZipFile( arch, "r" )
@@ -271,11 +276,11 @@ def unpack(arch, where):
     elif ext == ".tar":
         tarf = tarfile.open( arch, "r")
         tarf.extractall( path=where )
-    print "done"
+    print("done")
     return True
 
 #####################
-# Playing with eggs #  
+# Playing with eggs #
 #####################
 try:
     from setuptools.package_index import PackageIndex
@@ -288,17 +293,17 @@ try:
     can_egg_download = True
 except:
     can_egg_download = False
-    
+
 def download_egg(eggname, dir_):
     """Download an egg to a specific place"""
     if can_egg_download:
-        print "Downloading %s"%eggname
+        print("Downloading %s"%eggname)
         if BE.options.get("gforge"):
             add_private_gforge_repositories(BE.options.get("login"), BE.options.get("passwd"))
         log.set_verbosity(1)
         return pi.download(eggname, dir_)
     else:
-        print "Oups: Egg download in not available cause setuptools (or distribute) is not installed"
+        print("Oups: Egg download in not available cause setuptools (or distribute) is not installed")
         return False
 
 ##################################
@@ -311,7 +316,7 @@ def merge_list_dict(li):
     d = defaultdict(list)
     for k, v in li:
         d[k].extend(v)
-    return dict( (k, sj(v)) for k,v in d.iteritems() )
+    return dict( (k, sj(v)) for k,v in d.items() )
 
 CompiledRe = type(re_compile(""))
 def recursive_glob(dir_, patterns=None, strip_dir_=False, levels=-1):
@@ -367,7 +372,7 @@ def makedirs(pth, verbose=False):
     try:
         os.makedirs( pth )
         #print "ok"
-    except os.error, e:
+    except os.error as e:
         #print "already exists or access denied"
         if verbose:
             traceback.print_exc()
@@ -410,7 +415,7 @@ def ascii_file_replace(fname, oldstr, newstr):
 
     if patch:
         with open(fname, "w") as f:
-            print "patching", fname
+            print("patching", fname)
             f.write(txt)
 
 
@@ -485,9 +490,8 @@ def memoize(attr):
 #############################
 # A micro build environment #
 #############################
-class Tool(object):
-    __metaclass__ = MTool
 
+class Tool(with_metaclass(MTool,object)):
     class PyExecPaths(object):
         """Include this symbol in the default_paths
         list to add the python "scripts" folder to
@@ -538,10 +542,10 @@ class Tool(object):
     def get_path(self, no_install=False):
         verbose = BE.verbose
         if verbose:
-            print "Looking for %s path"%self.name
+            print("Looking for %s path"%self.name)
         pth = self._get_path(no_install)
         if pth and verbose:
-            print "\tGot it:", pth
+            print("\tGot it:", pth)
         return pth
 
     def _get_path(self, no_install=False):
@@ -556,7 +560,7 @@ class Tool(object):
                 try:
                     subprocess.call(exe_path, stdout=NullOutput, stderr=NullOutput)
                 except OSError:
-                    print "\tCalling", exe_path, "failed: bad path"
+                    print("\tCalling", exe_path, "failed: bad path")
                     return False
                 else:
                     return True
@@ -570,7 +574,7 @@ class Tool(object):
 
         # Look in default_paths:
         if self.default_paths is None or not len(self.default_paths):
-            print "\tNo default paths given, skipping"
+            print("\tNo default paths given, skipping")
         else:
             # 1) - Expand PyExecPaths and OriginalSystemPaths placeholders
             if Tool.PyExecPaths in self.default_paths:
@@ -603,18 +607,18 @@ class Tool(object):
 
         # Haven't found it yet, let's install it in wdr
         if self.url is None:
-            print "\tNo url to download tool from, skipping"
+            print("\tNo url to download tool from, skipping")
             return None
         if not self.__prompt_user():
-            print "\tUser refused download"
+            print("\tUser refused download")
             return None
 
-        print "\tWill now install %s to %s"%(self.name, wp)
+        print("\tWill now install %s to %s"%(self.name, wp))
         if not download(self.url, self.arch_name, archpath):
-            print "\tCouldn't download", self.name
+            print("\tCouldn't download", self.name)
             return None
         if not unpack(archpath, toolpath):
-            print "\tCouldn't unpack", self.name
+            print("\tCouldn't unpack", self.name)
             return None
 
         pth = into_subdir(toolpath, self.archive_subdir)
@@ -626,7 +630,7 @@ class Tool(object):
         delay = 5000
         def ask_user_if_download():
             try:
-                do_dl = raw_input().lower() == "y"
+                do_dl = input().lower() == "y"
             except:
                 do_dl = True
 
@@ -649,14 +653,12 @@ class Tool(object):
 
 
 
-class Compiler_(object):
-    __metaclass__ = MSingleton
-
+class Compiler_(with_metaclass(MSingleton,object)):
     default_32_comp = "https://gforge.inria.fr/frs/download.php/29029/MinGW-5.1.4_2-win32.egg"
 
     def __init__(self):
         self.options={}
-    
+
     def set_options(self, options):
         self.options = options.copy()
 
@@ -666,24 +668,24 @@ class Compiler_(object):
             compiler = os.path.join(self.get_bin_path(),"gcc.exe")
 
             subprocess.call(compiler+" --version", stdout=NullOutput)
-        except OSError, e:
-            print e
-            print "No MingW compiler found, you can specify its path with -c"
-            print "or install a default MingW compiler."
-            if raw_input("Install a default MingW? (Y/N). :").lower() == "y":
+        except OSError as e:
+            print(e)
+            print("No MingW compiler found, you can specify its path with -c")
+            print("or install a default MingW compiler.")
+            if input("Install a default MingW? (Y/N). :").lower() == "y":
                 self.install()
             else:
-                print "Cannot compile, continuing anyway..."
+                print("Cannot compile, continuing anyway...")
 
     def install(self):
-        print "Will now install a default 32 bits MingW compiler to c:\mingw"
-        print "Make sure you have to rights to do so and that the directory does NOT exist"
-        if raw_input("Proceed? (Y/N):").lower() == "y":
+        print("Will now install a default 32 bits MingW compiler to c:\mingw")
+        print("Make sure you have to rights to do so and that the directory does NOT exist")
+        if input("Proceed? (Y/N):").lower() == "y":
             ez_name  = "mingw.zip"
             archpath = pj(BE.working_path, ez_name)
             if download(default_32_comp, ez_name, archpath):
                 if not unpack(archpath, "c:\\mingw"):
-                    print "Couldn't install MingW32, continuing anyway..."
+                    print("Couldn't install MingW32, continuing anyway...")
 
     @memoize("comp_bin_path")
     def get_bin_path(self):
@@ -706,11 +708,11 @@ class Compiler_(object):
                 if f.location.lower().startswith(base):
                     v = pj(f.location, "bin")
             raise Exception("Mingw not found")
-        except Exception, e:
+        except Exception as e:
             v = r"c:\mingw\bin"
 
         if BE.verbose:
-            print "Using MingW path:", v
+            print("Using MingW path:", v)
         return v
 
     def version_gt(self, version):
@@ -765,9 +767,7 @@ Compiler = Compiler_()
 
 
 
-class BuildEnvironment(object):
-    __metaclass__ = MSingleton
-
+class BuildEnvironment(with_metaclass(MSingleton,object)):
     def __init__(self):
         self.options = {}
         # self.proj_builders = None
@@ -785,10 +785,10 @@ class BuildEnvironment(object):
 
     def set_options(self, options):
         self.options = options.copy()
-        Compiler.set_options(options)        
+        Compiler.set_options(options)
         self.tools = options.get("tools",[])[:]
         self.init()
-        
+
     @property
     def verbose(self):
         return self.options.get("verbose")
@@ -806,27 +806,27 @@ class BuildEnvironment(object):
         self.__fix_sys_path()
 
         if is_64bits_python():
-            if self.verbose: print "Doing a 64 bits compilation because we are using a 64 bits Python."
+            if self.verbose: print("Doing a 64 bits compilation because we are using a 64 bits Python.")
             if not Compiler.get_default_target() == 64:
-                print "Compiler is not a 64 bits compiler. Can it cross-compile?"
+                print("Compiler is not a 64 bits compiler. Can it cross-compile?")
                 if not Compiler.can_cross_compile():
-                    print "Cannot cross compile."
+                    print("Cannot cross compile.")
                     raise Exception("No compiler found for Windows 64 bits")
         else:
-            if self.verbose: print "Doing a 32 bits compilation because we are using a 32 bits Python."
+            if self.verbose: print("Doing a 32 bits compilation because we are using a 32 bits Python.")
             if not Compiler.get_default_target() == 32:
-                print "Compiler is not a 32 bits compiler"
+                print("Compiler is not a 32 bits compiler")
                 raise Exception("No compiler found for Windows 64 bits")
 
     # -- context manager protocol --
     def __enter__(self):
         try:
-            print self.proc_file_path
+            print(self.proc_file_path)
             with open(self.proc_file_path, "rb") as f:
                 txt  = f.read()
                 self.done_tasks = eval(txt)
         except:
-            print "%s not found, let's start from the very beginning"%self.proc_file_path
+            print("%s not found, let's start from the very beginning"%self.proc_file_path)
             self.done_tasks = {}
 
     def __exit__(self, exc_type, exc_value, traceback):
@@ -845,7 +845,7 @@ class BuildEnvironment(object):
         # list because we still want to process unskippable actions
         # of the other builders because they can extend os.env["PATH"]
         # or sys.path.
-        for buildercls in ( cls for meta in self.metabuilders for cls in meta.builders.itervalues() ):
+        for buildercls in ( cls for meta in self.metabuilders for cls in meta.builders.values() ):
             builder = buildercls()
             if builder.has_pending and builder.enabled:
 
@@ -930,27 +930,27 @@ class BuildEnvironment(object):
         self.ensure_python_lib()
         self.__overwrite_path()
 
-    def __overwrite_path(self):        
+    def __overwrite_path(self):
         tool_paths = []
         for tool in self.tools:
             tool = tool()
             pth = tool.get_path()
             if pth:
                 tool_paths.append(pth)
-                
+
         path = sj(tool_paths + [Compiler.get_bin_path()])
         if self.options["pass_path"]:
             path = sj( [self.original_path, path] )
 
         if path.endswith("\""):
-            print "Removing trailing PATH quotes as mingw32-make doesn't like them"
+            print("Removing trailing PATH quotes as mingw32-make doesn't like them")
             path = path.replace("\"", "")
         os.environ["PATH"] = path
 
     def __fix_sys_path(self):
         """Clean sys.path for this process so that we don't import
         existing eggs or site-installed thingys."""
-        our_egg_names = [name.strip("egg_") for name in MEgg.builders.iterkeys()]
+        our_egg_names = [name.strip("egg_") for name in MEgg.builders.keys()]
         for pth in sys.path[:] :
             pth_p = pth.lower()
             for egg_name in our_egg_names:
@@ -970,10 +970,10 @@ class BuildEnvironment(object):
 
         if not exists( dst ):
             if exists( src ):
-                print "Using PExports to create %s"%dst
+                print("Using PExports to create %s"%dst)
                 if not os.system( "pexports.exe %s > %s"%(src, dstdef) ):
                     if not os.system("dlltool -U -d %s -l %s"%(dstdef, dst) ):
-                        print "Created %s"%dst
+                        print("Created %s"%dst)
                     else:
                         raise Exception("Can't create %s, dlltool error: Python link will fail"%dst)
                 else:
@@ -981,7 +981,7 @@ class BuildEnvironment(object):
             else:
                 raise Exception("Can't create %s, %s not found: Python link will fail"%(dst,src))
         else:
-            print "Python lib is ok"
+            print("Python lib is ok")
 
 #a shorthand:
 BE=BuildEnvironment()
@@ -1012,7 +1012,7 @@ def in_dir(directory):
         calls f and moves back to BuildEnvironment.get_working_path()"""
         def wrapper(self, *args, **kwargs):
             d_ = rgetattr(self, directory)
-            print "changing to", d_, "for", f.__name__
+            print("changing to", d_, "for", f.__name__)
             os.chdir(d_)
             ret = f(self, *args, **kwargs)
             os.chdir(self.env.get_working_path())
@@ -1044,7 +1044,7 @@ def option_to_sys_path(option):
                 ret = f(self, *args, **kwargs)
                 os.environ["PATH"] = prev_pth
             else:
-                print "option_to_sys_path:", option, "not provided"
+                print("option_to_sys_path:", option, "not provided")
                 ret = f(self, *args, **kwargs)
             return ret
         return wrapper
@@ -1071,7 +1071,7 @@ def option_to_python_path(option):
                 sys.path = prev_pth
                 os.environ["PYTHONPATH"] = prev_py_pth
             else:
-                print "option_to_python_path:", option, "not provided"
+                print("option_to_python_path:", option, "not provided")
                 ret = f(self, *args, **kwargs)
             return ret
         return wrapper
@@ -1116,7 +1116,7 @@ class BaseBuilder(object):
 
     def get_task_restriction(self):
         return None
-        
+
     def __find_pending_tasks(self):
         tasks = []
         name  = self.name
@@ -1127,7 +1127,7 @@ class BaseBuilder(object):
             # that removes tasks from all_tasks
                 continue
             done   = self.env.is_task_done(name, task)
-            
+
             forced = False
             restriction = self.get_task_restriction()
             if restriction != None:
@@ -1155,25 +1155,25 @@ class BaseBuilder(object):
         forced_tasks = self.options.get(self.name, "")
 
         proc_str  = "Processing " + self.name
-        print "\n",proc_str
-        print "="*len(proc_str)
-        print "forced tasks are:", forced_tasks        
+        print("\n",proc_str)
+        print("="*len(proc_str))
+        print("forced tasks are:", forced_tasks)
 
-        for task, task_func, skippable in self.pending:        
+        for task, task_func, skippable in self.pending:
             if skippable and not should_process:
                 continue
             # doing unskippable actions like extending python or env PATH.
             # or we should_process is True
             nice_func = task_func.strip("_")
-            print "\t-->performing %s for %s"%(nice_func, self.name)
+            print("\t-->performing %s for %s"%(nice_func, self.name))
             success = getattr(self, task_func)()
             if success == Later:
-                print "\t-->%s for %s we be done later"%(nice_func, self.name)
+                print("\t-->%s for %s we be done later"%(nice_func, self.name))
             elif success == False:
-                print "\t-->%s for %s failed"%(nice_func, self.name)
+                print("\t-->%s for %s failed"%(nice_func, self.name))
                 if not should_process:
-                    print "-o %s was specified, ignoring error on package %s"% \
-                         (self.options.get("only"), self.name)
+                    print("-o %s was specified, ignoring error on package %s"% \
+                         (self.options.get("only"), self.name))
                     continue
                 return False
             else:
@@ -1184,11 +1184,7 @@ class BaseBuilder(object):
 
 
 
-class BaseProjectBuilder(BaseBuilder, object):
-    __metaclass__ = MProject
-
-    # The URL to fetch the sources from
-    # A None url implies the download has already done by someone else
+class BaseProjectBuilder(with_metaclass(MProject,BaseBuilder,object)):
     url = None
     # Name of the  local archive
     download_name  = None
@@ -1210,7 +1206,7 @@ class BaseProjectBuilder(BaseBuilder, object):
     # swallow stdout for these tasks:
     silent_tasks    = "fxy"
     # Only execute these tasks:
-    supported_tasks = "".join(all_tasks.keys())
+    supported_tasks = "".join(list(all_tasks.keys()))
 
     def __init__(self):
         BaseBuilder.__init__(self)
@@ -1220,7 +1216,7 @@ class BaseProjectBuilder(BaseBuilder, object):
 
     def get_task_restriction(self):
         return self.options.get("only_action_projs")
-        
+
     def download_source(self):
         # a proj with a none url implicitely means
         # the sources are already here because some
@@ -1235,21 +1231,21 @@ class BaseProjectBuilder(BaseBuilder, object):
         # the sources are already here because some
         # other proj installed it.
         if self.url is None:
-            print 'No url'
+            print('No url')
             return True
         if exists(self.sourcedir):
-            print 'already unpacked in '+repr(self.sourcedir)
+            print('already unpacked in '+repr(self.sourcedir))
             return True
         arch = arch or self.archname
         return unpack(arch, self.sourcedir)
 
     def fix_source_dir(self):
         try:
-            print "fixing sourcedir", self.sourcedir,
+            print("fixing sourcedir", self.sourcedir, end=' ')
             self.sourcedir = into_subdir(self.sourcedir, self.archive_subdir)
             if self.sourcedir is None:
                 raise Exception("Subdir should exist but doesn't, archive has probably not been unpacked")
-            print self.sourcedir
+            print(self.sourcedir)
         except:
             traceback.print_exc()
             return False
@@ -1310,7 +1306,7 @@ class BaseProjectBuilder(BaseBuilder, object):
         raise NotImplementedError
     def build(self):
         cmd = "mingw32-make -j " + str(self.options["jobs"])
-        print cmd
+        print(cmd)
         return subprocess.call( cmd ) == 0
     def patch(self):
         return True
@@ -1322,8 +1318,7 @@ class BaseProjectBuilder(BaseBuilder, object):
 class TemplateStr(string.Template):
     delimiter = "@"
 
-class BaseEggBuilder(BaseBuilder, object):
-    __metaclass__  = MEgg
+class BaseEggBuilder(with_metaclass(MEgg, BaseBuilder, object)):
     __oldsyspath__ = sys.path[:]
     # The egg depends on the Python version (allows correct egg naming)
     py_dependent   = True
@@ -1336,7 +1331,7 @@ class BaseEggBuilder(BaseBuilder, object):
                                   ("g",("_copy_egg_in_dir",True)),
                                  ])
     # Only execute these tasks:
-    supported_tasks = "".join(all_tasks.keys())
+    supported_tasks = "".join(list(all_tasks.keys()))
 
     def __init__(self,**kwargs):
         BaseBuilder.__init__(self, **kwargs)
@@ -1378,22 +1373,22 @@ class BaseEggBuilder(BaseBuilder, object):
 
     def get_task_restriction(self):
         return self.options.get("only_action_eggs")
-    
+
     def _glob_egg(self):
         eggs = glob.glob( pj(self.eggdir, "dist", "*.egg") )
         if len(eggs) == 0:
             raise Exception("No egg found for "+self.egg_name())
         elif len(eggs) > 1:
             raise Exception("Found multiple eggs for "+self.egg_name()+reduce(lambda x,y:x+"\t->%s\n"%y, eggs, "\n"))
-        return eggs[0]    
-        
+        return eggs[0]
+
     @try_except
     def _configure_script(self):
         with open( self.setup_in_name, "r") as input, \
              open( self.setup_out_name, "w") as output:
             conf = self.default_substitutions.copy()
             conf.update(self.script_substitutions())
-            conf = dict( (k,repr(v)) for k,v in conf.iteritems() )
+            conf = dict( (k,repr(v)) for k,v in conf.items() )
             template = TemplateStr(input.read())
             output.write(template.substitute(conf))
         return True
@@ -1421,25 +1416,25 @@ class BaseEggBuilder(BaseBuilder, object):
             self.use_cfg_login = True
             ret = self.upload_egg()
             if not ret:
-                print "No login or passwd provided, skipping egg upload"
+                print("No login or passwd provided, skipping egg upload")
                 return Later
             return ret
         return self.upload_egg()
-        
+
     @in_dir("eggdir")
     @try_except
     def _copy_egg_in_dir(self):
         dest_dir = self.options.get("dest_egg_dir")
         if not dest_dir:
-            print "Will not place egg in a directory"
+            print("Will not place egg in a directory")
             return True
 
         eggname  = self._glob_egg()
         destname = pj(dest_dir, split(eggname)[1])
         if exists(destname):
-            print "removing", destname
+            print("removing", destname)
             os.remove(destname)
-        print "copying", eggname, "to", destname
+        print("copying", eggname, "to", destname)
         shutil.copyfile(eggname, destname)
         return True
 
@@ -1499,8 +1494,8 @@ class InstalledPackageEggBuilder(BaseEggBuilder, object):
         BaseEggBuilder.__init__(self)
         try:
             p = self.package
-        except Exception, e:
-            print self.name, "disabled:", e
+        except Exception as e:
+            print(self.name, "disabled:", e)
             self.enabled = False
         else:
             self.enabled = True
@@ -1539,8 +1534,8 @@ class InstalledPackageEggBuilder(BaseEggBuilder, object):
 
     def script_substitutions(self):
         py_modules = recursive_glob(self.install_dir, Pattern.pymod)
-        data_files = recursive_glob_as_dict(self.install_dir,
-                    ",".join(["*.example","*.txt",Pattern.pyext,"*.c",".1"])).items()
+        data_files = list(recursive_glob_as_dict(self.install_dir,
+                    ",".join(["*.example","*.txt",Pattern.pyext,"*.c",".1"])).items())
         packages, package_dirs = self.find_packages_and_directories()
 
         d = dict ( PACKAGES = packages,
@@ -1580,7 +1575,7 @@ class setuptools(Tool):
     exe            = "easy_install"+exe_ext
     default_paths  = [ Tool.PyExecPaths ]
 
-    
+
 class openalea_deploy(Tool):
     installable    = False
     exe            = "alea_install"+exe_ext
@@ -1591,8 +1586,8 @@ class openalea_deploy(Tool):
 # -- MAIN LOOP AND RELATIVES -- #
 #################################
 def valid_builder(arg):
-    if arg in MProject.builders.keys() or \
-       arg in MEgg.builders.keys() :
+    if arg in list(MProject.builders.keys()) or \
+       arg in list(MEgg.builders.keys()) :
         return arg
     else:
         raise argparse.ArgumentError()
@@ -1602,7 +1597,7 @@ def build_epilog(metabuilders, dep_build_end=True):
     for mbuilder in metabuilders:
         m_name = mbuilder.ez_name
         epilog += "%s_ACTIONS are a concatenation of flags specifying what actions will be done:\n"%m_name.upper()
-        for proc, (funcname, skippable) in mbuilder.bases[0].all_tasks.iteritems():
+        for proc, (funcname, skippable) in mbuilder.bases[0].all_tasks.items():
             if skippable:
                 epilog += "\t%s : %s\n"%(proc, funcname.strip("_"))
         epilog += "\n"
@@ -1637,7 +1632,7 @@ def options_dep_build(parser):
     g.add_argument("--compiler", "-c", default=None,
                    help="Path to compiler binaries")
     g.add_argument("--only", "-o", default=None, action="append", type=valid_builder,
-                   help="Only process these project/eggs")    
+                   help="Only process these project/eggs")
     g.add_argument("--only-action-projs", default=None, metavar="PROJECT_ACTIONS",
                    help="For all projects to be processed, only do these action")
     g.add_argument("--only-action-eggs", default=None, metavar="EGG_ACTIONS",
@@ -1647,7 +1642,7 @@ def options_dep_build(parser):
     g.add_argument("--no-upload", "-n", action="store_const", const=True, default=False,
                    help="Do not upload eggs to forge")
     g.add_argument("--release", action="store_const", const=True, default=False,
-                   help="Upload eggs to openalea repository or vplants (if False - for testing).")    
+                   help="Upload eggs to openalea repository or vplants (if False - for testing).")
     g.add_argument("--dest-egg-dir", default=None, type=abspath,
                    help="Put generated eggs in a directory.")
     return parser
@@ -1666,7 +1661,7 @@ def options_metabuilders(parser, metabuilders):
     for mbuilder in metabuilders:
         m_name = mbuilder.ez_name
         g = parser.add_argument_group("Options controlling %s builder actions to force"%m_name)
-        for name, builder in mbuilder.builders.iteritems():
+        for name, builder in mbuilder.builders.items():
             if not builder.enabled:
                 continue
             g.add_argument("--"+name, default="",
@@ -1678,7 +1673,7 @@ def options_metabuilders(parser, metabuilders):
                 tools |= set(builder.required_tools)
 
 
-    for bname, opt_list in pkg_options.iteritems():
+    for bname, opt_list in pkg_options.items():
         g = parser.add_argument_group("Options for " + bname + " builder")
         for opt_name, default, help in opt_list:
             g.add_argument("--"+opt_name, default=default, help=help)
@@ -1733,7 +1728,7 @@ def main():
     os.environ["MAKE_FLAGS"] = "-j"+str(args.jobs)
     if args.no_upload:
         del BaseEggBuilder.all_tasks["u"]
-        
+
     if args.python is not None: #use another Python to compile, this is weird, maybe useless.
         python = args.python
         del args.python #or else we will nevert start!
diff --git a/src/openalea/deploy/system_dependencies/deploy_system.py b/src/openalea/deploy/system_dependencies/deploy_system.py
index 23ba1b5..bfe06d8 100644
--- a/src/openalea/deploy/system_dependencies/deploy_system.py
+++ b/src/openalea/deploy/system_dependencies/deploy_system.py
@@ -21,8 +21,9 @@
 __license__ = "Cecill-C"
 __revision__ = " $Id$"
 
-import distributions, dependency
+from . import distributions, dependency
 import sys
+from functools import reduce
 
 def install_dependencies(software, osname=None, fake=False):
     if osname is None:
@@ -35,23 +36,23 @@ def install_dependencies(software, osname=None, fake=False):
     voth = False
 
     if len(dependencies.runtime_distribution_packages()):
-        print "Do you wish to install the required runtime packages:\n"
-        print reduce(lambda x,y: str(x)+" "+str(y),
-                     dependencies.runtime_distribution_packages(), "") + " (y/n)?"
-        vrun = raw_input()
+        print("Do you wish to install the required runtime packages:\n")
+        print(reduce(lambda x,y: str(x)+" "+str(y),
+                     dependencies.runtime_distribution_packages(), "") + " (y/n)?")
+        vrun = input()
 
     if len(dependencies.development_distribution_packages()):
-        print "Do you wish to install the development packages:\n"
-        print reduce(lambda x,y: str(x)+" "+str(y),
-                     dependencies.development_distribution_packages(), "") + " (y/n)?"
-        vdev = raw_input()
+        print("Do you wish to install the development packages:\n")
+        print(reduce(lambda x,y: str(x)+" "+str(y),
+                     dependencies.development_distribution_packages(), "") + " (y/n)?")
+        vdev = input()
 
 
     if len(dependencies.other_packages()):
-        print "Do you wish to install the other packages:\n"
-        print reduce(lambda x,y: str(x)+" "+str(y),
-                     dependencies.other_packages(), "") + " (y/n)?"
-        voth = raw_input()
+        print("Do you wish to install the other packages:\n")
+        print(reduce(lambda x,y: str(x)+" "+str(y),
+                     dependencies.other_packages(), "") + " (y/n)?")
+        voth = input()
 
     if vrun == "y":
         theOs.install_packages(dependencies.runtime_distribution_packages(), fake)
@@ -76,13 +77,13 @@ for the one it is running on.
 
 def main():
 
-    print """
+    print("""
 ############################################################
 # THIS MODULE IS DEPRECATED, USE DEPLOY_SYSTEM2.PY INSTEAD #
 ############################################################
-"""
+""")
     if len(sys.argv)==1:
-        print usage%( reduce( lambda x, y: x+" "+y, distributions.canonical_dependencies.iterkeys() ), )
+        print(usage%( reduce( lambda x, y: x+" "+y, iter(distributions.canonical_dependencies.keys()) ), ))
         sys.exit(-1)
 
     software = sys.argv[1]
diff --git a/src/openalea/deploy/system_dependencies/deploy_system2.py b/src/openalea/deploy/system_dependencies/deploy_system2.py
index 08efd93..8956c78 100644
--- a/src/openalea/deploy/system_dependencies/deploy_system2.py
+++ b/src/openalea/deploy/system_dependencies/deploy_system2.py
@@ -1,733 +1,729 @@
-# -*- python -*-
-#
-#       openalea.deploy.platform_install
-#
-#       Copyright 2006-2012 INRIA - CIRAD - INRA
-#
-#       File author(s): Daniel Barbeau
-#       File Contributors(s):
-#                             - your name heredeploy/src/openalea/deploy/system_dependencies/deploy_system2.py
-#
-#       Distributed under the Cecill-C License.
-#       See accompanying file LICENSE.txt or copy at
-#           http://www.cecill.info/licences/Licence_CeCILL-C_V1-en.html
-#
-#       OpenAlea WebSite : http://openalea.gforge.inria.fr
-#
-###############################################################################
-
-from dependency_builder import MSingleton, BaseBuilder, BuildEnvironment, BE
-from dependency_builder import create_metabuilder, build_epilog
-from dependency_builder import options_metabuilders, options_common, options_gforge
-from dependency_builder import exe_ext, makedirs, download, download_egg, setuptools, openalea_deploy
-from collections import deque, OrderedDict
-import argparse
-import platform
-import subprocess
-import sys
-import urlparse
-from os.path import join as pj, isdir, splitext
-
-
-
-# --------------------------------------------------------------------------- #
-class MPlatformAPI(MSingleton):
-    apis = {}
-    def __init__(cls, name, bases, dic):
-        MSingleton.__init__(cls, name, bases, dic)
-        if object not in bases:
-            #print "adding", cls
-            MPlatformAPI.apis[name.lower()] = cls
-
-    @classmethod
-    def get(cls, item=None):
-        if item is None:
-            item = MPlatformAPI.get_platform_name()
-        item = cls.intersect_and_solve(item, cls.apis.keys(), sep="_")
-        item = item or "EggPackageAPI".lower()
-        return MPlatformAPI.apis[item]
-
-    @classmethod
-    def get_platform_name(cls):
-        """Creates a string out of the current platform with names seperated by whitespaces:
-        ex: "fedora 13 goddard" or "ubuntu 9.10 karmic"."""
-        _platform = None
-        system = platform.system().lower()
-        if system == "linux":
-            dist, number, name = platform.linux_distribution()
-            _platform = dist.lower() + " " + number.lower() + " " + name.lower()
-        elif system == "windows":
-            dist, host, name, number, proc, procinfo = platform.uname()
-            _platform = dist.lower() + " " + number.lower() + " " + name.lower() + " "+ proc.lower()
-        else:
-            warnings.warn("Currently unhandled system : " + system + ". Implement me please.")
-        return _platform        
-
-    @classmethod
-    def intersect_platform_names(cls, requestedPlatformNames, availablePlatformNames):
-       """Find intersection between platformName and packageList subdictionnary keys.
-       ex : ["fedora", "13", "goddard"] and ["fedora", "ubuntu"]
-       returns (["fedora"]), [("13", "goddard"])"""
-
-       requestedPlatformNames = set(requestedPlatformNames)
-       availablePlatformNames = set(availablePlatformNames)
-       return requestedPlatformNames&availablePlatformNames, requestedPlatformNames-availablePlatformNames
-
-    @classmethod
-    def intersect_and_solve(cls, platform, candidates, conflictSolve=lambda x: x[0], sep=" "):
-        """ Given a platform name from BaseOsFactory.get_platform() or similar, and
-        candidate names (ex: ["fedora 13 goddard", "ubuntu 9.10 karmic"]), this method
-        will return the largest intersection of both lists and use conflictSolve to
-        resolve conflicts when there are several intersections with the same number
-        of items."""
-
-        assert platform is not None
-        #We find the right distribution class by intersecting
-        #the platform description with the X_X_PackageNames classes
-        #whose names are mangled.
-        #the correct disctribution class is the one with which the
-        #intersection is the largest. If there's equality between two
-        #the conflict is solved using the conflictSolve function.
-        platform = platform.split(" ")
-        maxIntersectionAmount  = 0
-        maxIntersectionDistrib = None
-        for dist in candidates:
-            intersections = cls.intersect_platform_names(platform, dist.split(sep))[0]
-            numInters = len(intersections)
-            if numInters > maxIntersectionAmount:
-                maxIntersectionAmount = numInters
-                maxIntersectionDistrib = dist
-            elif numInters == maxIntersectionAmount and numInters > 0:
-                if isinstance(maxIntersectionDistrib, list):
-                    maxIntersectionDistrib.append(dist)
-                elif maxIntersectionDistrib is not None:
-                    maxIntersectionDistrib = [maxIntersectionDistrib, dist]
-                else:
-                    maxIntersectionDistrib = dist
-        if isinstance(maxIntersectionDistrib, list):
-            maxIntersectionDistrib = conflictSolve(maxIntersectionDistrib)
-        return maxIntersectionDistrib
-
-    @classmethod
-    def install_packages(cls, *packages):
-        # we build a chain of responsability
-        first = cls.get()
-        c_o_r = [first]
-        c_o_r += [api_cls for api_cls in cls.apis.itervalues() \
-                  if api_cls!=first and \
-                  not issubclass(api_cls, NativePackageAPI)] #because this should be "first"
-        
-        print c_o_r
-        action_men = OrderedDict()
-        
-        to_inst = packages[:]
-        while( len(to_inst) and len(c_o_r)):
-            api = c_o_r.pop(0)()
-            handled, to_inst = api.decanonify(*to_inst)
-            action_men[api] = handled
-
-        print "The packages will be installed:"
-        for api, handled in action_men.iteritems():
-            print "\t - using", api.__class__.__name__, "for"
-            for h in handled:
-                print "\t\t", h
-
-        if len(to_inst):
-            print "Will NOT install these (couldn't find any way to install them) :"
-            for p in to_inst:
-                print "\t", p
-                
-        if not BE.options.get("yes_to_all") and raw_input("Do you want to proceed? (y/n):").lower() != "y":
-            return False
-
-        for api, handled in action_men.iteritems():
-            apiName = api.__class__.__name__
-            print "Using", apiName
-            if not BE.options.get("yes_to_all") and BE.options.get("confirm_each") and raw_input("Install the %s group? (y/n):"%apiName).lower()=="n":
-                continue
-            if api.install_packages(*handled) == False:
-                return False
-        return True
-
-class DepSpec(object):
-    pass
-        
-class Egg(DepSpec):
-    def __init__(self, spec):
-        self.spec = spec
-    def __str__(self):
-        return self.spec        
-    def __repr__(self):
-        return repr(self.spec)
-    def __hash__(self):
-        return hash(self.spec)
-    def __eq__(self, other):
-        return self.spec.__eq__(other.spec)    
-    def __ne__(self, other):
-        return self.spec.__ne__(other.spec)
-        
-class WinInst(DepSpec): #for exes and msi
-    def __init__(self, url, ez_name=None):
-        self.url = url
-        self.ez_name = ez_name or urlparse.urlsplit(url).path.split("/")[-1]
-    def __str__(self):        
-        if BE.verbose:
-            return self.url+ " => " + self.ez_name
-        else:
-            return self.ez_name
-    def __repr__(self):
-        return "WinInst(" + repr(self.url) + ", " + repr(self.ez_name) + ")"
-    def __hash__(self):
-        return hash(self.ez_name)
-    def __eq__(self, other):
-        return self.ez_name.__eq__(other.ez_name)    
-    def __ne__(self, other):
-        return self.spec.__ne__(other.ez_name)
-
-class NA(object):
-    """Use this in a packagemap:
-    {"glut":NA} means that for this particular
-    dependency will be delegated to another PlatformAPI."""    
-    pass
-
-class Ignore(object):
-    """Use this in a packagemap:
-    {"glut":Ignore} means that for this particular
-    dependency no error will be raised i.e. doesn't need to be installed."""    
-    pass
-
-    
-class PlatformAPI(object):
-    
-    __metaclass__ = MPlatformAPI
-        
-    packagemap = None
-    
-    handled_decanofied_types = set([str])
-
-    def __init__(self):
-        # A map to translate from canonical name
-        # to distribution name.
-        deps = get_all_deps()
-        self.packagemap = dict.fromkeys( deps, NA )       
-
-    def update(self, other):
-        self.packagemap.update(other)    
-    
-    def install_packages( self, *packages ):
-        raise NotImplementedError
-        
-    def decanonify( self, *packages ):
-        handled = set()#[]
-        not_handled = set()
-        for pkg in packages:
-            deca_list = self.packagemap[pkg]
-            #make everything a list
-            if isinstance(deca_list, str):
-                deca_list = deca_list.split(" ")
-            elif isinstance(deca_list, DepSpec):
-                deca_list = [deca_list]
-            elif isinstance(deca_list, list):
-                pass
-            elif deca_list==Ignore:
-                print "Info: ignoring", pkg
-                continue
-            elif deca_list==NA:
-                print "Info: Delegating", pkg
-                not_handled.add(pkg)
-                continue
-            else:
-                raise Exception("Bad dependency type: %s is %s. The package must be added to this platform's package map."%(pkg, deca_list.__name__))
-            for deca in deca_list:
-                if set([deca, type(deca)]) or set(self.handled_decanofied_types):
-                    handled.add(deca)
-                else:
-                    not_handled.add(pkg)
-        return list(handled), list(not_handled)
-        
-
-class BaseEggPackageAPI(PlatformAPI, object):
-    handled_decanofied_types = set([Egg])
-    def install_packages(self, *packages):
-        inst = openalea_deploy().get_path()
-        if inst:
-            if BE.options.get("gforge"):
-                inst = pj(inst, "alea_install%s -g"%exe_ext)
-            else:
-                inst = pj(inst, "alea_install%s "%exe_ext)
-        else:
-            inst = setuptools().get_path()
-            if inst:
-                inst = pj(inst, "easy_install%s"%exe_ext)
-            else:
-                return False
-                
-        if not BE.options.get("no_sudo_easy_install"):
-            inst = "sudo " + inst
-
-        tempdir = BE.options.get("dldir")
-        if not isdir(tempdir):
-            makedirs(tempdir)        
-        for pkg in packages:
-            # first download:
-            if not download_egg(pkg.spec, tempdir):
-                return False
-            if BE.options.get("dl_only"):
-                print "skipping installation"
-                continue
-            cmd = inst + " -i "+ tempdir + " " + pkg.spec
-            print cmd            
-            if subprocess.call(cmd, shell=True):
-                return False
-        return True
-        
-
-class NativePackageAPI(PlatformAPI, object):
-    """This API uses the distributions installation
-    system (yum, apt-get), and can delegate to EggPackageAPI"""
-
-    # shell command to install a package
-    install_cmd = None
-    
-    def install_packages(self, *packages): 
-        cmd = self.install_cmd + " " + " ".join(packages)
-        print cmd
-        if subprocess.call( cmd, shell=True ):
-            return False
-        return True        
-
-
-class BaseWindowsPackageAPI(NativePackageAPI):
-    handled_decanofied_types = set([WinInst])
-    
-    def install_packages(self, *packages):
-        tempdir = BE.options.get("dldir")
-        if not isdir(tempdir):
-            makedirs(tempdir)
-        for pkg in packages:
-            assert isinstance(pkg, WinInst)
-            # First we download to pkg_pth, then we install
-            pkg_pth = pj(tempdir, pkg.ez_name)
-            if not download(pkg.url, pkg.ez_name, pkg_pth):
-                return False
-            if BE.options.get("dl_only"):
-                print "skipping installation"
-                continue
-            name, ext = splitext(pkg.ez_name.lower())
-            if ext == ".exe":
-                if subprocess.call(pkg_pth, shell=True):
-                    return False
-            elif ext == ".msi":
-                if subprocess.call("msiexec /i "+pkg_pth):
-                    return False
-            else:
-                print "trying to install %s but found no way to do so."%pkg_pth
-        return True   
-           
-        
-def get_dependencies(package):
-        dep_tree = get_canonical_dependency_tree()
-        
-        package_deps = dep_tree.get(package, None)
-        if not package_deps:
-            raise Exception("No such package : " + package)
-
-        # non recursive dependency browsing, Euler tour.
-        pkgList          = set()
-        ancestors        = deque()
-        childs           = deque()
-        currentPkg       = package
-        currentPkgChilds = package_deps.__iter__()
-        while currentPkg:
-            hasChilds = True
-            child     = None
-            try: child = currentPkgChilds.next()
-            except: hasChilds = False
-            if hasChilds:
-                ancestors.append(currentPkg)
-                childs.append(currentPkgChilds)
-                currentPkg = child
-                currentPkgChildsList = dep_tree.get(currentPkg, None)
-                if currentPkgChildsList:
-                    currentPkgChilds = currentPkgChildsList.__iter__()
-                else:
-                    currentPkgChilds = None
-            else:
-                if currentPkg != package:
-                    pkgList.add(currentPkg)
-                    if len(ancestors) >= 1:
-                        currentPkg = ancestors.pop()
-                        currentPkgChilds = childs.pop()
-                    else:
-                        currentPkg = None #stops the loop
-                else:
-                    currentPkg = None
-
-        return list(pkgList)
-        
-        
-    
-# --------------------------------------------------------------------------- #
-def get_all_deps():
-    return [ dep for deps in get_canonical_dependency_tree().itervalues() for dep in deps \
-            if dep not in ("openalea", "vplants", "alinea") ]
-            
-def get_canonical_dependency_tree():
-    """Returns a copy of the dependency tree"""
-    return __canonical_dependencies.copy()
-
-# -- our dependency tree --
-__canonical_dependencies = {
-    "rpy2"   : ["r"],
-    "soappy" : ["fpconst", "wstools"], 
-    "openalea" : ["pyqt4", "numpy", "scipy", "matplotlib", 
-                  "pyqscintilla", "setuptools", "pil", "soappy", "pylsm", "pylibtiff"],
-    "vplants"  : [  "ann-dev",
-                    "bison-dev",
-                    "boostmath",
-                    "boostmath-dev",
-                    "boostpython",
-                    "boostpython-dev",
-                    "cgal",
-                    "cgal-dev",
-                    "compilers-dev",
-                    "flex-dev",
-                    "glut",
-                    "glut-dev",
-                    "gnuplot",
-                    "nose-dev",
-                    "networkx",
-                    "openalea",
-                    "pyopengl",
-                    "pyqt4",
-                    "pyqt4-dev",
-                    "qhull",
-                    "qhull-dev",
-                    "readline",
-                    "readline-dev",
-                    "rpy2",
-                    "scons-dev",
-                    "sip4-dev",
-                    "svn-dev",
-                    ],
-    "alinea"   : ["vplants", "openalea"]
-}
-
-if "win32" in sys.platform:
-    __canonical_dependencies["openalea"].append("pywin32")
-
-
-#################################################
-# -------------- Distributions ---------------- #
-#################################################
-class EggPackageAPI(BaseEggPackageAPI):
-    def __init__(self):
-        BaseEggPackageAPI.__init__(self)
-        self.update({"ann-dev" : Egg("ann"),
-                     "bison-dev" : Egg("bisonflex==2.4.1_2.5.35"),
-                     "boost-dev" : Egg("boost"),
-                     "boostmath" : Egg("boost"),
-                     "boostmath-dev" : Egg("boost"),
-                     "boostpython" : Egg("boost"),
-                     "boostpython-dev" : Egg("boost"),
-                     "cgal" :  Egg("cgal"),
-                     "cgal-dev" : Egg("cgal"),
-                     "compilers-dev" : Egg("mingw==5.1.4_4b"),
-                     "flex-dev" : Egg("bisonflex==2.4.1_2.5.35"),
-                     "fpconst" : Egg("fpconst==0.7.2"),
-                     "glut" : NA,
-                     "glut-dev" : NA,
-                     "gnuplot" : Egg("gnuplot"),
-                     "matplotlib" : Egg("matplotlib"),
-                     "networkx" : Egg("networkx"),
-                     "nose-dev" : Egg("nose"),
-                     "numpy" : Egg("numpy"),
-                     "pil" : Egg("PIL"),
-                     "pylsm" : Egg("pylsm"),
-                     "pyopengl": Egg("pyopengl"),
-                     "pyqt4" : [Egg("qt4"), Egg("pyqglviewer")],
-                     "pyqt4-dev" : Egg("qt4_dev"),
-                     "pyqscintilla" : Egg("qt4"),
-                     "qhull" : Egg("qhull"),
-                     "qhull-dev" : Egg("qhull"),
-                     "readline": Egg("mingw_rt==5.1.4_4b"),
-                     "readline-dev": Egg("mingw==5.1.4_4b"),
-                     "rpy2" : Egg("rpy2"),
-                     "setuptools" : NA,
-                     "sip4-dev" : Egg("qt4_dev"),
-                     "scipy" : Egg("scipy"),
-                     "scons-dev" : Egg("scons"),
-                     "soappy" : Egg("soappy"),
-                     "svn-dev" : NA,
-                     "wstools" : Egg("wstools==0.3"),
-             })
-             
-class Ubuntu(NativePackageAPI):
-    install_cmd = "sudo apt-get install"
-
-    def __init__(self):
-        NativePackageAPI.__init__(self)
-        self.update({"bison-dev" : "bison",
-                     "boost-dev" : "libboost-dev",
-                     "boostmath" : "libboost-math",
-                     "boostmath-dev" : "libboost-math-dev",
-                     "boostpython" : "libboost-python",
-                     "boostpython-dev" : "libboost-python-dev",
-                     "cgal" :  "libcgal3",
-                     "cgal-dev" : "libcgal-dev",
-                     "compilers-dev" : "g++ gfortran",
-                     "flex-dev" : "flex",
-                     "glut" : "freeglut3",
-                     "glut-dev" : "freeglut3-dev",
-                     "matplotlib" : "python-matplotlib",
-                     "networkx": "python-networkx",
-                     "nose-dev" : "python-nose",
-                     "numpy" : "python-numpy",
-                     "pil" : "python-imaging",
-                     "pyopengl":"python-opengl",
-                     "pyqt4" : "python-qt4 python-qt4-gl",
-                     "pyqt4-dev" : "python-qt4-dev libqt4-opengl-dev",
-                     "pyqscintilla" : "python-qscintilla2",
-                     "qhull" : "libqhull5",
-                     "qhull-dev" : "libqhull-dev",
-                     "readline": "readline-common",
-                     "readline-dev": "libreadline-dev",
-                     "rpy2" : "python-rpy2",
-                     "setuptools" : "python-setuptools",
-                     "sip4-dev" : "python-sip4",
-                     "scipy" : "python-scipy",
-                     "sip4-dev" : "python-sip4",
-                     "scons-dev" :  "scons",
-                     "soappy" : "python-soappy",
-                     "svn-dev" : "subversion",
-                     "wstools": Ignore,
-             })
-
-class Ubuntu_Karmic(Ubuntu):
-    def __init__(self):
-        Ubuntu.__init__(self)
-        self.update({
-                     "boostmath" : "libboost-math1.38.0",
-                     "boostmath-dev" : "libboost-math1.38-dev libboost1.38-dev",
-                     "boostpython" : "libboost-python1.38.0",
-                     "boostpython-dev" : "libboost-python1.38-dev",
-        })
-
-class Ubuntu_Lucid(Ubuntu):
-    def __init__(self):
-        Ubuntu.__init__(self)
-        self.update({
-                     "boostmath" : "libboost-math",
-                     "boostmath-dev" : "libboost-math-dev",
-                     "boostpython" : "libboost-python",
-                     "boostpython-dev" : "libboost-python-dev",
-                     "cgal" :  "libcgal4",
-                     "sip4-dev":"python-sip-dev",
-        })
-
-class Ubuntu_Natty(Ubuntu_Lucid):
-    def __init__(self):
-        Ubuntu_Lucid.__init__(self)
-        self.update({
-                     "boostmath" : "libboost-math1.42.0",
-                     "boostpython" : "libboost-python1.42.0",
-                     "cgal" :  "libcgal5",
-        })
-
-class Ubuntu_Oneiric(Ubuntu_Natty):
-    def __init__(self):
-        Ubuntu_Natty.__init__(self)
-        self.update({
-                     "boostmath" : "libboost-math1.46.1",
-                     "boostmath-dev" : "libboost-math-dev",
-                     "boostpython-dev" : "libboost-python-dev",
-                     "boostpython" : "libboost-python1.46.1",
-                     "cgal" :  "libcgal7",
-        })
-        
-class Ubuntu_Precise(Ubuntu_Oneiric):
-    def __init__(self):
-        Ubuntu_Oneiric.__init__(self)
-        self.update({
-                     "boostmath" : "libboost-math1.48.0",
-                     "boostmath-dev" : "libboost-math1.48-dev libboost1.48-dev",
-                     "boostpython" : "libboost-python1.48.0",
-                     "boostpython-dev" : "libboost-python1.48-dev",
-                     "cgal" :  "libcgal8",
-        })
-
-
-class Fedora(NativePackageAPI):
-    install_cmd = "sudo yum install"
-    
-    def __init__(self):
-        NativePackageAPI.__init__(self)
-        self.update({"ann-dev": NA,
-                     "bison-dev" : "bison-devel",
-                     "boostmath" : "boost-math",
-                     "boostmath-dev" : "boost-devel",
-                     "boostpython" : "boost-python",
-                     "boostpython-dev" : "boost-devel",
-                     "cgal" :  "CGAL",
-                     "cgal-dev" : "CGAL-devel",
-                     "compilers-dev" : "gcc-c++ gcc-gfortran",
-                     "flex-dev" : "flex flex-static",
-                     "fpconst" : "python-fpconst",
-                     "glut" : "freeglut",
-                     "glut-dev" : "freeglut-devel",
-                     "gnuplot": "gnuplot",
-                     "matplotlib" : "python-matplotlib",
-                     "networkx" : "python-networkx",
-                     "nose-dev" : "python-nose",
-                     "numpy" : "numpy",
-                     "pil" : "python-imaging",
-                     "pyopengl":"PyOpenGL",
-                     "pyqt4" : "PyQt4",
-                     "pyqt4-dev" : "PyQt4-devel",
-                     "pyqscintilla" : "qscintilla-python",
-                     "qhull" : "qhull",
-                     "qhull-dev" : "qhull-devel qhull-dev", #probably to handle ancient naming
-                     "readline": "readline",
-                     "readline-dev": "readline-devel readline",
-                     "rpy2" : "rpy",
-                     "setuptools" : "python-setuptools",
-                     "scipy" : "scipy",
-                     "sip4-dev" : "sip-devel",
-                     "scons-dev" :  "scons",
-                     "soappy" : "SOAPpy",
-                     "svn-dev" : "subversion",
-                     "wstools": Ignore
-             })
-             
-class Fedora_16(Fedora):
-    def __init__(self):
-        Fedora.__init__(self)
-        self.update({"ann-dev": "ann-devel"})
-
-
-class Windows(BaseWindowsPackageAPI):
-    def __init__(self):
-        BaseWindowsPackageAPI.__init__(self)
-        self.update({
-                     "python" : WinInst("http://python.org/ftp/python/2.7.2/python-2.7.2.msi"),
-                     "pywin32" : WinInst("http://freefr.dl.sourceforge.net/project/pywin32/pywin32/Build%20217/pywin32-217.win32-py2.7.exe"),
-                     "matplotlib" : WinInst("http://freefr.dl.sourceforge.net/project/matplotlib/matplotlib/matplotlib-1.1.0/matplotlib-1.1.0.win32-py2.7.exe"),
-                     "numpy" : WinInst("http://freefr.dl.sourceforge.net/project/numpy/NumPy/1.6.1/numpy-1.6.1-win32-superpack-python2.7.exe"),
-                     "pil" : WinInst("http://effbot.org/media/downloads/PIL-1.1.7.win32-py2.7.exe"),
-                     "pyopengl": WinInst("http://pypi.python.org/packages/any/P/PyOpenGL/PyOpenGL-3.0.1.win32.exe#md5=513cc194af65af4c5a640cf9a1bd8462"),
-                     "r": WinInst("http://mirror.ibcp.fr/pub/CRAN/bin/windows/base/old/2.14.2/R-2.14.2-win.exe"),
-                     "setuptools" : WinInst("http://pypi.python.org/packages/2.7/s/setuptools/setuptools-0.6c11.win32-py2.7.exe#md5=57e1e64f6b7c7f1d2eddfc9746bbaf20"),
-                     "scipy" : WinInst("http://freefr.dl.sourceforge.net/project/scipy/scipy/0.10.1/scipy-0.10.1-win32-superpack-python2.7.exe"),
-                     "svn-dev" : WinInst("http://freefr.dl.sourceforge.net/project/win32svn/1.6.9/Setup-Subversion-1.6.9.msi")
-             })
-
-
-             
-#################################################
-# ----------- Main and Friends ---------------- #
-#################################################
-# This is how we interface with the dependency_builder
-# infrastructure.
-
-MDeploy = create_metabuilder("deploy")
-
-class BaseDepBuilder(BaseBuilder, object):
-    __metaclass__  = MDeploy
-    # Task management:
-    all_tasks      = OrderedDict([("i",("_install",True)),                                  
-                                 ])
-    # Only execute these tasks:
-    supported_tasks = "".join(all_tasks.keys())
-    
-    required_tools = [setuptools, openalea_deploy]
-    
-    def _install(self):    
-        pkg = self.options["package"]
-        all_pkgs = get_all_deps()
-        dependencies = get_dependencies(pkg)
-        for to_skip in self.options["skip_inst"]:
-            print "removing", to_skip, "from dependencies"
-            assert to_skip in all_pkgs
-            dependencies.remove(to_skip)
-        
-        #split dependencies into dev and rt
-        rt  = []
-        dev = []
-        for dep in dependencies:
-            append_to = dev if dep.endswith("-dev") else rt
-            append_to.append(dep)
-        
-        to_inst = [] if self.options["no_rt"] else rt
-        to_inst += [] if self.options["no_dev"] else dev
-        
-        try:
-            to_inst.remove("openalea")
-        except:
-            pass
-        try:
-            to_inst.remove("vplants")
-        except:
-            pass
-        try:
-            to_inst.remove("alinea")
-        except:
-            pass            
-        print "Will install dependencies for", MPlatformAPI.get_platform_name()
-
-        return MPlatformAPI.install_packages(*to_inst)
-        
-class DepBuilder(BaseDepBuilder):
-    pass
-        
-        
-def options_installer(parser):
-    g = parser.add_argument_group("System deploy options")
-    g.add_argument("--confirm-each", action="store_true", 
-                   help="User must confirm each group of packages to install. default=False")
-    g.add_argument("--dldir" , default="system_deploy2_temp",
-                   help="Directory where downloads will be stored, if any.")
-    g.add_argument("--no-rt",  action="store_true", 
-                   help="Do not install runtime dependencies.")
-    g.add_argument("--no-dev",  action="store_true",
-                   help="Do not install development dependencies.")
-    g.add_argument("--dl-only", "-x", action="store_true", 
-                   help="Download dependencies but do not install them.")
-    g.add_argument("--yes-to-all", "-y", action="store_true",
-                   help="Download dependencies but do not install them.")    
-    g.add_argument("--skip-inst", default="",
-                   help="name of packages to download but not to install (comma seperated).")
-    g.add_argument("--no-sudo-easy-install", action="store_false",
-                   help="Don't use sudo to install with easy-install (use this with virtualenv).")
-    g.add_argument("package", default="openalea", choices=["openalea", "vplants", "alinea"], 
-                   help="The package to install dependencies for.")
-    return parser
-    
-def parse_arguments(metabuilders):
-    parser = argparse.ArgumentParser(description="Install Openalea dependencies",
-                                     epilog=build_epilog(metabuilders, dep_build_end=False),
-                                     formatter_class=argparse.RawDescriptionHelpFormatter,)
-                                     
-    parser, tools = options_metabuilders( options_gforge(options_common(parser)),
-                                          metabuilders )
-    parser = options_installer(parser)
-                                         
-    return parser.parse_args(), tools
-        
-def main():                                                
-    metabuilders = [MDeploy]
-    args, tools = parse_arguments(metabuilders)
-
-    args.skip_inst = args.skip_inst.split(",") if args.skip_inst != "" else []
-    options = vars(args)
-    options["tools"] = tools
-    options["pass_path"]=True
-    env = BuildEnvironment()
-    env.set_options(options)
-    env.set_metabuilders(metabuilders)
-    return env.build()
-
-
-    
-
-if __name__ ==  "__main__":
-    sys.exit( main() == False )
+# -*- python -*-
+#
+#       openalea.deploy.platform_install
+#
+#       Copyright 2006-2012 INRIA - CIRAD - INRA
+#
+#       File author(s): Daniel Barbeau
+#       File Contributors(s):
+#                             - your name heredeploy/src/openalea/deploy/system_dependencies/deploy_system2.py
+#
+#       Distributed under the Cecill-C License.
+#       See accompanying file LICENSE.txt or copy at
+#           http://www.cecill.info/licences/Licence_CeCILL-C_V1-en.html
+#
+#       OpenAlea WebSite : http://openalea.gforge.inria.fr
+#
+###############################################################################
+
+from .dependency_builder import MSingleton, BaseBuilder, BuildEnvironment, BE
+from .dependency_builder import create_metabuilder, build_epilog
+from .dependency_builder import options_metabuilders, options_common, options_gforge
+from .dependency_builder import exe_ext, makedirs, download, download_egg, setuptools, openalea_deploy
+from collections import deque, OrderedDict
+import argparse
+import platform
+import subprocess
+import sys
+import urllib.parse
+from os.path import join as pj, isdir, splitext
+from six import with_metaclass
+
+
+# --------------------------------------------------------------------------- #
+class MPlatformAPI(MSingleton):
+    apis = {}
+    def __init__(cls, name, bases, dic):
+        MSingleton.__init__(cls, name, bases, dic)
+        if object not in bases:
+            #print "adding", cls
+            MPlatformAPI.apis[name.lower()] = cls
+
+    @classmethod
+    def get(cls, item=None):
+        if item is None:
+            item = MPlatformAPI.get_platform_name()
+        item = cls.intersect_and_solve(item, list(cls.apis.keys()), sep="_")
+        item = item or "EggPackageAPI".lower()
+        return MPlatformAPI.apis[item]
+
+    @classmethod
+    def get_platform_name(cls):
+        """Creates a string out of the current platform with names seperated by whitespaces:
+        ex: "fedora 13 goddard" or "ubuntu 9.10 karmic"."""
+        _platform = None
+        system = platform.system().lower()
+        if system == "linux":
+            dist, number, name = platform.linux_distribution()
+            _platform = dist.lower() + " " + number.lower() + " " + name.lower()
+        elif system == "windows":
+            dist, host, name, number, proc, procinfo = platform.uname()
+            _platform = dist.lower() + " " + number.lower() + " " + name.lower() + " "+ proc.lower()
+        else:
+            warnings.warn("Currently unhandled system : " + system + ". Implement me please.")
+        return _platform        
+
+    @classmethod
+    def intersect_platform_names(cls, requestedPlatformNames, availablePlatformNames):
+       """Find intersection between platformName and packageList subdictionnary keys.
+       ex : ["fedora", "13", "goddard"] and ["fedora", "ubuntu"]
+       returns (["fedora"]), [("13", "goddard"])"""
+
+       requestedPlatformNames = set(requestedPlatformNames)
+       availablePlatformNames = set(availablePlatformNames)
+       return requestedPlatformNames&availablePlatformNames, requestedPlatformNames-availablePlatformNames
+
+    @classmethod
+    def intersect_and_solve(cls, platform, candidates, conflictSolve=lambda x: x[0], sep=" "):
+        """ Given a platform name from BaseOsFactory.get_platform() or similar, and
+        candidate names (ex: ["fedora 13 goddard", "ubuntu 9.10 karmic"]), this method
+        will return the largest intersection of both lists and use conflictSolve to
+        resolve conflicts when there are several intersections with the same number
+        of items."""
+
+        assert platform is not None
+        #We find the right distribution class by intersecting
+        #the platform description with the X_X_PackageNames classes
+        #whose names are mangled.
+        #the correct disctribution class is the one with which the
+        #intersection is the largest. If there's equality between two
+        #the conflict is solved using the conflictSolve function.
+        platform = platform.split(" ")
+        maxIntersectionAmount  = 0
+        maxIntersectionDistrib = None
+        for dist in candidates:
+            intersections = cls.intersect_platform_names(platform, dist.split(sep))[0]
+            numInters = len(intersections)
+            if numInters > maxIntersectionAmount:
+                maxIntersectionAmount = numInters
+                maxIntersectionDistrib = dist
+            elif numInters == maxIntersectionAmount and numInters > 0:
+                if isinstance(maxIntersectionDistrib, list):
+                    maxIntersectionDistrib.append(dist)
+                elif maxIntersectionDistrib is not None:
+                    maxIntersectionDistrib = [maxIntersectionDistrib, dist]
+                else:
+                    maxIntersectionDistrib = dist
+        if isinstance(maxIntersectionDistrib, list):
+            maxIntersectionDistrib = conflictSolve(maxIntersectionDistrib)
+        return maxIntersectionDistrib
+
+    @classmethod
+    def install_packages(cls, *packages):
+        # we build a chain of responsability
+        first = cls.get()
+        c_o_r = [first]
+        c_o_r += [api_cls for api_cls in cls.apis.values() \
+                  if api_cls!=first and \
+                  not issubclass(api_cls, NativePackageAPI)] #because this should be "first"
+        
+        print(c_o_r)
+        action_men = OrderedDict()
+        
+        to_inst = packages[:]
+        while( len(to_inst) and len(c_o_r)):
+            api = c_o_r.pop(0)()
+            handled, to_inst = api.decanonify(*to_inst)
+            action_men[api] = handled
+
+        print("The packages will be installed:")
+        for api, handled in action_men.items():
+            print("\t - using", api.__class__.__name__, "for")
+            for h in handled:
+                print("\t\t", h)
+
+        if len(to_inst):
+            print("Will NOT install these (couldn't find any way to install them) :")
+            for p in to_inst:
+                print("\t", p)
+                
+        if not BE.options.get("yes_to_all") and input("Do you want to proceed? (y/n):").lower() != "y":
+            return False
+
+        for api, handled in action_men.items():
+            apiName = api.__class__.__name__
+            print("Using", apiName)
+            if not BE.options.get("yes_to_all") and BE.options.get("confirm_each") and input("Install the %s group? (y/n):"%apiName).lower()=="n":
+                continue
+            if api.install_packages(*handled) == False:
+                return False
+        return True
+
+class DepSpec(object):
+    pass
+        
+class Egg(DepSpec):
+    def __init__(self, spec):
+        self.spec = spec
+    def __str__(self):
+        return self.spec        
+    def __repr__(self):
+        return repr(self.spec)
+    def __hash__(self):
+        return hash(self.spec)
+    def __eq__(self, other):
+        return self.spec.__eq__(other.spec)    
+    def __ne__(self, other):
+        return self.spec.__ne__(other.spec)
+        
+class WinInst(DepSpec): #for exes and msi
+    def __init__(self, url, ez_name=None):
+        self.url = url
+        self.ez_name = ez_name or urllib.parse.urlsplit(url).path.split("/")[-1]
+    def __str__(self):        
+        if BE.verbose:
+            return self.url+ " => " + self.ez_name
+        else:
+            return self.ez_name
+    def __repr__(self):
+        return "WinInst(" + repr(self.url) + ", " + repr(self.ez_name) + ")"
+    def __hash__(self):
+        return hash(self.ez_name)
+    def __eq__(self, other):
+        return self.ez_name.__eq__(other.ez_name)    
+    def __ne__(self, other):
+        return self.spec.__ne__(other.ez_name)
+
+class NA(object):
+    """Use this in a packagemap:
+    {"glut":NA} means that for this particular
+    dependency will be delegated to another PlatformAPI."""    
+    pass
+
+class Ignore(object):
+    """Use this in a packagemap:
+    {"glut":Ignore} means that for this particular
+    dependency no error will be raised i.e. doesn't need to be installed."""    
+    pass
+
+    
+class PlatformAPI(with_metaclass(MPlatformAPI,object)):
+    
+    packagemap = None
+    
+    handled_decanofied_types = set([str])
+
+    def __init__(self):
+        # A map to translate from canonical name
+        # to distribution name.
+        deps = get_all_deps()
+        self.packagemap = dict.fromkeys( deps, NA )       
+
+    def update(self, other):
+        self.packagemap.update(other)    
+    
+    def install_packages( self, *packages ):
+        raise NotImplementedError
+        
+    def decanonify( self, *packages ):
+        handled = set()#[]
+        not_handled = set()
+        for pkg in packages:
+            deca_list = self.packagemap[pkg]
+            #make everything a list
+            if isinstance(deca_list, str):
+                deca_list = deca_list.split(" ")
+            elif isinstance(deca_list, DepSpec):
+                deca_list = [deca_list]
+            elif isinstance(deca_list, list):
+                pass
+            elif deca_list==Ignore:
+                print("Info: ignoring", pkg)
+                continue
+            elif deca_list==NA:
+                print("Info: Delegating", pkg)
+                not_handled.add(pkg)
+                continue
+            else:
+                raise Exception("Bad dependency type: %s is %s. The package must be added to this platform's package map."%(pkg, deca_list.__name__))
+            for deca in deca_list:
+                if set([deca, type(deca)]) or set(self.handled_decanofied_types):
+                    handled.add(deca)
+                else:
+                    not_handled.add(pkg)
+        return list(handled), list(not_handled)
+        
+
+class BaseEggPackageAPI(PlatformAPI, object):
+    handled_decanofied_types = set([Egg])
+    def install_packages(self, *packages):
+        inst = openalea_deploy().get_path()
+        if inst:
+            if BE.options.get("gforge"):
+                inst = pj(inst, "alea_install%s -g"%exe_ext)
+            else:
+                inst = pj(inst, "alea_install%s "%exe_ext)
+        else:
+            inst = setuptools().get_path()
+            if inst:
+                inst = pj(inst, "easy_install%s"%exe_ext)
+            else:
+                return False
+                
+        if not BE.options.get("no_sudo_easy_install"):
+            inst = "sudo " + inst
+
+        tempdir = BE.options.get("dldir")
+        if not isdir(tempdir):
+            makedirs(tempdir)        
+        for pkg in packages:
+            # first download:
+            if not download_egg(pkg.spec, tempdir):
+                return False
+            if BE.options.get("dl_only"):
+                print("skipping installation")
+                continue
+            cmd = inst + " -i "+ tempdir + " " + pkg.spec
+            print(cmd)            
+            if subprocess.call(cmd, shell=True):
+                return False
+        return True
+        
+
+class NativePackageAPI(PlatformAPI, object):
+    """This API uses the distributions installation
+    system (yum, apt-get), and can delegate to EggPackageAPI"""
+
+    # shell command to install a package
+    install_cmd = None
+    
+    def install_packages(self, *packages): 
+        cmd = self.install_cmd + " " + " ".join(packages)
+        print(cmd)
+        if subprocess.call( cmd, shell=True ):
+            return False
+        return True        
+
+
+class BaseWindowsPackageAPI(NativePackageAPI):
+    handled_decanofied_types = set([WinInst])
+    
+    def install_packages(self, *packages):
+        tempdir = BE.options.get("dldir")
+        if not isdir(tempdir):
+            makedirs(tempdir)
+        for pkg in packages:
+            assert isinstance(pkg, WinInst)
+            # First we download to pkg_pth, then we install
+            pkg_pth = pj(tempdir, pkg.ez_name)
+            if not download(pkg.url, pkg.ez_name, pkg_pth):
+                return False
+            if BE.options.get("dl_only"):
+                print("skipping installation")
+                continue
+            name, ext = splitext(pkg.ez_name.lower())
+            if ext == ".exe":
+                if subprocess.call(pkg_pth, shell=True):
+                    return False
+            elif ext == ".msi":
+                if subprocess.call("msiexec /i "+pkg_pth):
+                    return False
+            else:
+                print("trying to install %s but found no way to do so."%pkg_pth)
+        return True   
+           
+        
+def get_dependencies(package):
+        dep_tree = get_canonical_dependency_tree()
+        
+        package_deps = dep_tree.get(package, None)
+        if not package_deps:
+            raise Exception("No such package : " + package)
+
+        # non recursive dependency browsing, Euler tour.
+        pkgList          = set()
+        ancestors        = deque()
+        childs           = deque()
+        currentPkg       = package
+        currentPkgChilds = package_deps.__iter__()
+        while currentPkg:
+            hasChilds = True
+            child     = None
+            try: child = next(currentPkgChilds)
+            except: hasChilds = False
+            if hasChilds:
+                ancestors.append(currentPkg)
+                childs.append(currentPkgChilds)
+                currentPkg = child
+                currentPkgChildsList = dep_tree.get(currentPkg, None)
+                if currentPkgChildsList:
+                    currentPkgChilds = currentPkgChildsList.__iter__()
+                else:
+                    currentPkgChilds = None
+            else:
+                if currentPkg != package:
+                    pkgList.add(currentPkg)
+                    if len(ancestors) >= 1:
+                        currentPkg = ancestors.pop()
+                        currentPkgChilds = childs.pop()
+                    else:
+                        currentPkg = None #stops the loop
+                else:
+                    currentPkg = None
+
+        return list(pkgList)
+        
+        
+    
+# --------------------------------------------------------------------------- #
+def get_all_deps():
+    return [ dep for deps in get_canonical_dependency_tree().values() for dep in deps \
+            if dep not in ("openalea", "vplants", "alinea") ]
+            
+def get_canonical_dependency_tree():
+    """Returns a copy of the dependency tree"""
+    return __canonical_dependencies.copy()
+
+# -- our dependency tree --
+__canonical_dependencies = {
+    "rpy2"   : ["r"],
+    "soappy" : ["fpconst", "wstools"], 
+    "openalea" : ["pyqt4", "numpy", "scipy", "matplotlib", 
+                  "pyqscintilla", "setuptools", "pil", "soappy", "pylsm", "pylibtiff"],
+    "vplants"  : [  "ann-dev",
+                    "bison-dev",
+                    "boostmath",
+                    "boostmath-dev",
+                    "boostpython",
+                    "boostpython-dev",
+                    "cgal",
+                    "cgal-dev",
+                    "compilers-dev",
+                    "flex-dev",
+                    "glut",
+                    "glut-dev",
+                    "gnuplot",
+                    "nose-dev",
+                    "networkx",
+                    "openalea",
+                    "pyopengl",
+                    "pyqt4",
+                    "pyqt4-dev",
+                    "qhull",
+                    "qhull-dev",
+                    "readline",
+                    "readline-dev",
+                    "rpy2",
+                    "scons-dev",
+                    "sip4-dev",
+                    "svn-dev",
+                    ],
+    "alinea"   : ["vplants", "openalea"]
+}
+
+if "win32" in sys.platform:
+    __canonical_dependencies["openalea"].append("pywin32")
+
+
+#################################################
+# -------------- Distributions ---------------- #
+#################################################
+class EggPackageAPI(BaseEggPackageAPI):
+    def __init__(self):
+        BaseEggPackageAPI.__init__(self)
+        self.update({"ann-dev" : Egg("ann"),
+                     "bison-dev" : Egg("bisonflex==2.4.1_2.5.35"),
+                     "boost-dev" : Egg("boost"),
+                     "boostmath" : Egg("boost"),
+                     "boostmath-dev" : Egg("boost"),
+                     "boostpython" : Egg("boost"),
+                     "boostpython-dev" : Egg("boost"),
+                     "cgal" :  Egg("cgal"),
+                     "cgal-dev" : Egg("cgal"),
+                     "compilers-dev" : Egg("mingw==5.1.4_4b"),
+                     "flex-dev" : Egg("bisonflex==2.4.1_2.5.35"),
+                     "fpconst" : Egg("fpconst==0.7.2"),
+                     "glut" : NA,
+                     "glut-dev" : NA,
+                     "gnuplot" : Egg("gnuplot"),
+                     "matplotlib" : Egg("matplotlib"),
+                     "networkx" : Egg("networkx"),
+                     "nose-dev" : Egg("nose"),
+                     "numpy" : Egg("numpy"),
+                     "pil" : Egg("PIL"),
+                     "pylsm" : Egg("pylsm"),
+                     "pyopengl": Egg("pyopengl"),
+                     "pyqt4" : [Egg("qt4"), Egg("pyqglviewer")],
+                     "pyqt4-dev" : Egg("qt4_dev"),
+                     "pyqscintilla" : Egg("qt4"),
+                     "qhull" : Egg("qhull"),
+                     "qhull-dev" : Egg("qhull"),
+                     "readline": Egg("mingw_rt==5.1.4_4b"),
+                     "readline-dev": Egg("mingw==5.1.4_4b"),
+                     "rpy2" : Egg("rpy2"),
+                     "setuptools" : NA,
+                     "sip4-dev" : Egg("qt4_dev"),
+                     "scipy" : Egg("scipy"),
+                     "scons-dev" : Egg("scons"),
+                     "soappy" : Egg("soappy"),
+                     "svn-dev" : NA,
+                     "wstools" : Egg("wstools==0.3"),
+             })
+             
+class Ubuntu(NativePackageAPI):
+    install_cmd = "sudo apt-get install"
+
+    def __init__(self):
+        NativePackageAPI.__init__(self)
+        self.update({"bison-dev" : "bison",
+                     "boost-dev" : "libboost-dev",
+                     "boostmath" : "libboost-math",
+                     "boostmath-dev" : "libboost-math-dev",
+                     "boostpython" : "libboost-python",
+                     "boostpython-dev" : "libboost-python-dev",
+                     "cgal" :  "libcgal3",
+                     "cgal-dev" : "libcgal-dev",
+                     "compilers-dev" : "g++ gfortran",
+                     "flex-dev" : "flex",
+                     "glut" : "freeglut3",
+                     "glut-dev" : "freeglut3-dev",
+                     "matplotlib" : "python-matplotlib",
+                     "networkx": "python-networkx",
+                     "nose-dev" : "python-nose",
+                     "numpy" : "python-numpy",
+                     "pil" : "python-imaging",
+                     "pyopengl":"python-opengl",
+                     "pyqt4" : "python-qt4 python-qt4-gl",
+                     "pyqt4-dev" : "python-qt4-dev libqt4-opengl-dev",
+                     "pyqscintilla" : "python-qscintilla2",
+                     "qhull" : "libqhull5",
+                     "qhull-dev" : "libqhull-dev",
+                     "readline": "readline-common",
+                     "readline-dev": "libreadline-dev",
+                     "rpy2" : "python-rpy2",
+                     "setuptools" : "python-setuptools",
+                     "sip4-dev" : "python-sip4",
+                     "scipy" : "python-scipy",
+                     "sip4-dev" : "python-sip4",
+                     "scons-dev" :  "scons",
+                     "soappy" : "python-soappy",
+                     "svn-dev" : "subversion",
+                     "wstools": Ignore,
+             })
+
+class Ubuntu_Karmic(Ubuntu):
+    def __init__(self):
+        Ubuntu.__init__(self)
+        self.update({
+                     "boostmath" : "libboost-math1.38.0",
+                     "boostmath-dev" : "libboost-math1.38-dev libboost1.38-dev",
+                     "boostpython" : "libboost-python1.38.0",
+                     "boostpython-dev" : "libboost-python1.38-dev",
+        })
+
+class Ubuntu_Lucid(Ubuntu):
+    def __init__(self):
+        Ubuntu.__init__(self)
+        self.update({
+                     "boostmath" : "libboost-math",
+                     "boostmath-dev" : "libboost-math-dev",
+                     "boostpython" : "libboost-python",
+                     "boostpython-dev" : "libboost-python-dev",
+                     "cgal" :  "libcgal4",
+                     "sip4-dev":"python-sip-dev",
+        })
+
+class Ubuntu_Natty(Ubuntu_Lucid):
+    def __init__(self):
+        Ubuntu_Lucid.__init__(self)
+        self.update({
+                     "boostmath" : "libboost-math1.42.0",
+                     "boostpython" : "libboost-python1.42.0",
+                     "cgal" :  "libcgal5",
+        })
+
+class Ubuntu_Oneiric(Ubuntu_Natty):
+    def __init__(self):
+        Ubuntu_Natty.__init__(self)
+        self.update({
+                     "boostmath" : "libboost-math1.46.1",
+                     "boostmath-dev" : "libboost-math-dev",
+                     "boostpython-dev" : "libboost-python-dev",
+                     "boostpython" : "libboost-python1.46.1",
+                     "cgal" :  "libcgal7",
+        })
+        
+class Ubuntu_Precise(Ubuntu_Oneiric):
+    def __init__(self):
+        Ubuntu_Oneiric.__init__(self)
+        self.update({
+                     "boostmath" : "libboost-math1.48.0",
+                     "boostmath-dev" : "libboost-math1.48-dev libboost1.48-dev",
+                     "boostpython" : "libboost-python1.48.0",
+                     "boostpython-dev" : "libboost-python1.48-dev",
+                     "cgal" :  "libcgal8",
+        })
+
+
+class Fedora(NativePackageAPI):
+    install_cmd = "sudo yum install"
+    
+    def __init__(self):
+        NativePackageAPI.__init__(self)
+        self.update({"ann-dev": NA,
+                     "bison-dev" : "bison-devel",
+                     "boostmath" : "boost-math",
+                     "boostmath-dev" : "boost-devel",
+                     "boostpython" : "boost-python",
+                     "boostpython-dev" : "boost-devel",
+                     "cgal" :  "CGAL",
+                     "cgal-dev" : "CGAL-devel",
+                     "compilers-dev" : "gcc-c++ gcc-gfortran",
+                     "flex-dev" : "flex flex-static",
+                     "fpconst" : "python-fpconst",
+                     "glut" : "freeglut",
+                     "glut-dev" : "freeglut-devel",
+                     "gnuplot": "gnuplot",
+                     "matplotlib" : "python-matplotlib",
+                     "networkx" : "python-networkx",
+                     "nose-dev" : "python-nose",
+                     "numpy" : "numpy",
+                     "pil" : "python-imaging",
+                     "pyopengl":"PyOpenGL",
+                     "pyqt4" : "PyQt4",
+                     "pyqt4-dev" : "PyQt4-devel",
+                     "pyqscintilla" : "qscintilla-python",
+                     "qhull" : "qhull",
+                     "qhull-dev" : "qhull-devel qhull-dev", #probably to handle ancient naming
+                     "readline": "readline",
+                     "readline-dev": "readline-devel readline",
+                     "rpy2" : "rpy",
+                     "setuptools" : "python-setuptools",
+                     "scipy" : "scipy",
+                     "sip4-dev" : "sip-devel",
+                     "scons-dev" :  "scons",
+                     "soappy" : "SOAPpy",
+                     "svn-dev" : "subversion",
+                     "wstools": Ignore
+             })
+             
+class Fedora_16(Fedora):
+    def __init__(self):
+        Fedora.__init__(self)
+        self.update({"ann-dev": "ann-devel"})
+
+
+class Windows(BaseWindowsPackageAPI):
+    def __init__(self):
+        BaseWindowsPackageAPI.__init__(self)
+        self.update({
+                     "python" : WinInst("http://python.org/ftp/python/2.7.2/python-2.7.2.msi"),
+                     "pywin32" : WinInst("http://freefr.dl.sourceforge.net/project/pywin32/pywin32/Build%20217/pywin32-217.win32-py2.7.exe"),
+                     "matplotlib" : WinInst("http://freefr.dl.sourceforge.net/project/matplotlib/matplotlib/matplotlib-1.1.0/matplotlib-1.1.0.win32-py2.7.exe"),
+                     "numpy" : WinInst("http://freefr.dl.sourceforge.net/project/numpy/NumPy/1.6.1/numpy-1.6.1-win32-superpack-python2.7.exe"),
+                     "pil" : WinInst("http://effbot.org/media/downloads/PIL-1.1.7.win32-py2.7.exe"),
+                     "pyopengl": WinInst("http://pypi.python.org/packages/any/P/PyOpenGL/PyOpenGL-3.0.1.win32.exe#md5=513cc194af65af4c5a640cf9a1bd8462"),
+                     "r": WinInst("http://mirror.ibcp.fr/pub/CRAN/bin/windows/base/old/2.14.2/R-2.14.2-win.exe"),
+                     "setuptools" : WinInst("http://pypi.python.org/packages/2.7/s/setuptools/setuptools-0.6c11.win32-py2.7.exe#md5=57e1e64f6b7c7f1d2eddfc9746bbaf20"),
+                     "scipy" : WinInst("http://freefr.dl.sourceforge.net/project/scipy/scipy/0.10.1/scipy-0.10.1-win32-superpack-python2.7.exe"),
+                     "svn-dev" : WinInst("http://freefr.dl.sourceforge.net/project/win32svn/1.6.9/Setup-Subversion-1.6.9.msi")
+             })
+
+
+             
+#################################################
+# ----------- Main and Friends ---------------- #
+#################################################
+# This is how we interface with the dependency_builder
+# infrastructure.
+
+MDeploy = create_metabuilder("deploy")
+
+class BaseDepBuilder(with_metaclass(MDeploy,BaseBuilder, object)):
+    all_tasks      = OrderedDict([("i",("_install",True)),                                  
+                                 ])
+    # Only execute these tasks:
+    supported_tasks = "".join(list(all_tasks.keys()))
+    
+    required_tools = [setuptools, openalea_deploy]
+    
+    def _install(self):    
+        pkg = self.options["package"]
+        all_pkgs = get_all_deps()
+        dependencies = get_dependencies(pkg)
+        for to_skip in self.options["skip_inst"]:
+            print("removing", to_skip, "from dependencies")
+            assert to_skip in all_pkgs
+            dependencies.remove(to_skip)
+        
+        #split dependencies into dev and rt
+        rt  = []
+        dev = []
+        for dep in dependencies:
+            append_to = dev if dep.endswith("-dev") else rt
+            append_to.append(dep)
+        
+        to_inst = [] if self.options["no_rt"] else rt
+        to_inst += [] if self.options["no_dev"] else dev
+        
+        try:
+            to_inst.remove("openalea")
+        except:
+            pass
+        try:
+            to_inst.remove("vplants")
+        except:
+            pass
+        try:
+            to_inst.remove("alinea")
+        except:
+            pass            
+        print("Will install dependencies for", MPlatformAPI.get_platform_name())
+
+        return MPlatformAPI.install_packages(*to_inst)
+        
+class DepBuilder(BaseDepBuilder):
+    pass
+        
+        
+def options_installer(parser):
+    g = parser.add_argument_group("System deploy options")
+    g.add_argument("--confirm-each", action="store_true", 
+                   help="User must confirm each group of packages to install. default=False")
+    g.add_argument("--dldir" , default="system_deploy2_temp",
+                   help="Directory where downloads will be stored, if any.")
+    g.add_argument("--no-rt",  action="store_true", 
+                   help="Do not install runtime dependencies.")
+    g.add_argument("--no-dev",  action="store_true",
+                   help="Do not install development dependencies.")
+    g.add_argument("--dl-only", "-x", action="store_true", 
+                   help="Download dependencies but do not install them.")
+    g.add_argument("--yes-to-all", "-y", action="store_true",
+                   help="Download dependencies but do not install them.")    
+    g.add_argument("--skip-inst", default="",
+                   help="name of packages to download but not to install (comma seperated).")
+    g.add_argument("--no-sudo-easy-install", action="store_false",
+                   help="Don't use sudo to install with easy-install (use this with virtualenv).")
+    g.add_argument("package", default="openalea", choices=["openalea", "vplants", "alinea"], 
+                   help="The package to install dependencies for.")
+    return parser
+    
+def parse_arguments(metabuilders):
+    parser = argparse.ArgumentParser(description="Install Openalea dependencies",
+                                     epilog=build_epilog(metabuilders, dep_build_end=False),
+                                     formatter_class=argparse.RawDescriptionHelpFormatter,)
+                                     
+    parser, tools = options_metabuilders( options_gforge(options_common(parser)),
+                                          metabuilders )
+    parser = options_installer(parser)
+                                         
+    return parser.parse_args(), tools
+        
+def main():                                                
+    metabuilders = [MDeploy]
+    args, tools = parse_arguments(metabuilders)
+
+    args.skip_inst = args.skip_inst.split(",") if args.skip_inst != "" else []
+    options = vars(args)
+    options["tools"] = tools
+    options["pass_path"]=True
+    env = BuildEnvironment()
+    env.set_options(options)
+    env.set_metabuilders(metabuilders)
+    return env.build()
+
+
+    
+
+if __name__ ==  "__main__":
+    sys.exit( main() == False )
diff --git a/src/openalea/deploy/system_dependencies/distributions.py b/src/openalea/deploy/system_dependencies/distributions.py
index f163099..2f0cb2a 100644
--- a/src/openalea/deploy/system_dependencies/distributions.py
+++ b/src/openalea/deploy/system_dependencies/distributions.py
@@ -16,7 +16,7 @@
 # THIS MODULE IS DEPRECATED, USE DEPLOY_SYSTEM2.PY INSTEAD #
 ############################################################
 
-import dependency
+from . import dependency
 
 
 # -- our dependency tree --
diff --git a/src/openalea/deploy/system_dependencies/egg_rules.py b/src/openalea/deploy/system_dependencies/egg_rules.py
index 7833084..343c065 100644
--- a/src/openalea/deploy/system_dependencies/egg_rules.py
+++ b/src/openalea/deploy/system_dependencies/egg_rules.py
@@ -1,346 +1,346 @@
-# -*- python -*-
-#
-#       openalea.deploy.dependency_builder
-#
-#       Copyright 2006-2012 INRIA - CIRAD - INRA
-#
-#       File author(s): Daniel Barbeau
-#       File Contributors(s):   
-#                             - Yassin Refahi,
-#                             - Frederic Boudon,
-#
-#       Distributed under the Cecill-C License.
-#       See accompanying file LICENSE.txt or copy at
-#           http://www.cecill.info/licences/Licence_CeCILL-C_V1-en.html
-#
-#       OpenAlea WebSite : http://openalea.gforge.inria.fr
-#
-###############################################################################
-
-################################################################################
-# - EGG BUILDERS - EGG BUILDERS - EGG BUILDERS - EGG BUILDERS - EGG BUILDERS - #
-# !!!!   THE ORDER OF CLASS DEFINITIONS IS THE ORDER OF EGG COMPILATION    !!!!#
-################################################################################        
-class egg_mingw_rt(BaseEggBuilder):
-    license = "PublicDomain for MingW runtime. GLP or LGPL for some libraries."
-    authors = "The Mingw Project"
-    description = "Mingw Development (compiler, linker, libs, includes)"
-    py_dependent   = False
-    arch_dependent = True
-    version        = "5.1.4_4b"
-    def script_substitutions(self):
-        mgw = mingwrt()
-        libdirs = {"bin":mgw.install_dll_dir}
-        return dict( 
-                    VERSION  = self.version,
-                    LIB_DIRS = libdirs,
-                    )                
-
-class egg_mingw(BaseEggBuilder):
-    license = "PublicDomain for MingW runtime. GLP or LGPL for some libraries."
-    authors = "The Mingw Project"
-    description = "Mingw Runtime"
-    py_dependent   = False
-    arch_dependent = True
-    def script_substitutions(self):
-        cpath = Compiler.get_bin_path()
-        mingwbase = pj(cpath,os.pardir)
-        subd  = os.listdir( mingwbase )
-        subd.remove("EGG-INFO")
-        subd.remove("bin")
-        subd.remove("include")
-        data = []
-        
-        for dir in subd:
-            dat = recursive_glob_as_dict(pj(mingwbase,dir), "*", strip_keys=True, prefix_key=dir).items()         
-            data += [ (d, [f for f in t if not f.endswith(".dll")]) for d,t in dat]
-
-        bindirs = {"bin": cpath}
-        incdirs = {"include": pj(mingwbase, "include")}
-            
-        return dict( 
-                    VERSION  = egg_mingw_rt.version,
-                    BIN_DIRS = bindirs,
-                    INC_DIRS = incdirs,
-                    DATA_FILES   = data,
-                    )  
-    
-class egg_qt4(BaseEggBuilder):
-    license = "General Public License V3"
-    authors = "Riverbank Computing (Sip+PyQt4+QSCintilla) & Nokia (Qt4)"
-    description = "Sip+PyQt4+QScintilla Runtime packaged as an egg for windows-gcc"
-    py_dependent   = True
-    arch_dependent = True
-    def script_substitutions(self):        
-        qt4_   = qt4()
-        pyqt4_ = pyqt4()
-        pysci_ = pyqscintilla()
-        sip_   = sip()
-        # dlls are the union of qt dlls and plugins directories (which is actually the same!)
-        # qscis apis are recursive from qt4 (need to list all files)        
-        qscis    = recursive_glob_as_dict(pysci_.qsci_dir, Pattern.sciapi, strip_keys=True, prefix_key="qsci").items()
-        extra_pyqt4_mods = recursive_glob_as_dict(pj(pyqt4_.install_site_dir,"PyQt4"), Pattern.pyall, strip_keys=True, prefix_key="PyQt4").items()
-        print "laaaaaaaaaaaaaaaajfdshfsdosfdo", extra_pyqt4_mods
-        sip_mods = recursive_glob_as_dict(sip_.install_site_dir, Pattern.pyall, strip_keys=True, levels=1).items()
-
-        lib_dirs    = {"PyQt4": qt4_.install_dll_dir}
-        package_dir = {"PyQt4": pj(pyqt4_.install_site_dir, "PyQt4")}
-        
-        from openalea.vpltk.qt import QtCore
-        from setuptools import find_packages
-        return dict( 
-                    VERSION  = QtCore.QT_VERSION_STR,
-                    PACKAGES = find_packages(pyqt4_.install_site_dir, "PyQt4"),
-                    PACKAGE_DIRS = package_dir,
-                    PACKAGE_DATA = {'' : [Pattern.pyext]},
-                    
-                    LIB_DIRS         = lib_dirs,
-                    DATA_FILES       = qscis+sip_mods+extra_pyqt4_mods,
-                    INSTALL_REQUIRES = [egg_mingw_rt.egg_name()]
-                    )  
-                    
-class egg_qt4_dev(BaseEggBuilder):
-    license = "General Public License V3"
-    authors = "Riverbank Computing (Sip+PyQt4+QSCintilla) & Nokia (Qt4)"
-    description = "Sip+PyQt4+QScintilla Development packaged as an egg for windows-gcc"
-    py_dependent   = True
-    arch_dependent = True
-    def script_substitutions(self):
-        qt4_   = qt4()
-        pyqt4_ = pyqt4()
-        sip_   = sip()
-        # binaries are the union of qt, pyqt and sip binaries 
-        bin_dirs = {"bin":qt4_.install_bin_dir}
-        # includes are recursive subdirectories and the union of qt and sip includes               
-        incs = recursive_glob_as_dict( qt4_.install_inc_dir, Pattern.qtinc, strip_keys=True, prefix_key="include", dirs=True).items() + \
-               recursive_glob_as_dict( sip_.install_inc_dir, Pattern.qtinc, strip_keys=True, prefix_key="include", dirs=True).items()
-        inc_dirs = merge_list_dict( incs )
-        # libs are recursive subdirectories of qt libs          
-        libs = recursive_glob_as_dict(qt4_.install_lib_dir, Pattern.qtstalib, strip_keys=True, prefix_key="lib").items()
-        # sip files are recursive subdirectories and the union of pyqt4 and...
-        sips = recursive_glob_as_dict(pyqt4_.install_sip_dir, Pattern.sipfiles, strip_keys=True, prefix_key="sip").items()
-        # sources are recursive subdirectories and the union of qt4 and that all (CPP have been removed)...
-        srcs = recursive_glob_as_dict(qt4_.install_src_dir, Pattern.qtsrc, strip_keys=True, prefix_key="src").items()
-        # tra files are recursive subdirectories in qt4
-        tra = recursive_glob_as_dict(qt4_.install_tra_dir, Pattern.qttransl, strip_keys=True, prefix_key="translations").items()
-        # mks files are recursive subdirectories in qt4
-        mks = recursive_glob_as_dict(qt4_.install_mks_dir, Pattern.qtmkspec, strip_keys=True, prefix_key="mkspecs").items()        
-        # plugins files are recursive subdirectories in qt4
-        plu = recursive_glob_as_dict(qt4_.install_plu_lib_dir, Pattern.qtstalib, strip_keys=True, prefix_key="plugins").items()        
-
-        from openalea.vpltk.qt import QtCore
-        
-        return dict( 
-                    VERSION          = QtCore.QT_VERSION_STR,                   
-                    BIN_DIRS         = bin_dirs,
-                    INC_DIRS         = inc_dirs,
-                    DATA_FILES       = libs+sips+srcs+tra+mks+plu,
-                    INSTALL_REQUIRES = [egg_qt4.egg_name()]
-                    )  
-                    
-class egg_pyqglviewer(BaseEggBuilder):
-    license = "General Public License"
-    authors = "libQGLViewer developers for libQGLViewer, PyQGLViewer (INRIA) developers for PyQGLViewer"
-    description = "Win-GCC version of PyQGLViewer"
-    py_dependent   = True
-    arch_dependent = True
-    def script_substitutions(self):
-        qt4_   = qt4()
-        qglv_   = qglviewer()
-        pyqglv_   = pyqglviewer()
-        
-        pyqgl_mods = recursive_glob_as_dict(pyqglv_.install_site_dir, Pattern.pyall, strip_keys=True, levels=1).items()
-        # includes are recursive subdirectories of qglviewer           
-        incs = recursive_glob_as_dict( qglv_.install_inc_dir, Pattern.include, strip_keys=True, prefix_key="include", dirs=True).items()
-        inc_dirs = merge_list_dict( incs )
-        # libs are recursive subdirectories of qt libs          
-        libs = recursive_glob_as_dict(qglv_.install_lib_dir, Pattern.qtstalib, strip_keys=True, prefix_key="lib").items()
-        # sip files are recursive subdirectories of pyqglviewer sip installation directory
-        sips = recursive_glob_as_dict(pyqglv_.install_sip_dir, Pattern.sipfiles, strip_keys=True, prefix_key="sip").items()
-        # examples are recursive subdirectories of pyqglviewer examples installation directory contains various types of files
-        exas = recursive_glob_as_dict(pyqglv_.install_exa_dir, Pattern.any, strip_keys=True, prefix_key="examples").items()        
-        
-        lib_dirs    = {"" : qglv_.install_dll_dir}
-        data_files  = exas+sips+libs+pyqgl_mods
-        
-        import PyQGLViewer
-        
-        return dict( 
-                    VERSION      = PyQGLViewer.QGLViewerVersionString(),                                  
-                    PACKAGE_DATA = {'' : [Pattern.pyext]},
-                    #PACKAGE_DIRS = package_dir,                    
-                    LIB_DIRS     = lib_dirs,
-                    INC_DIRS     = inc_dirs,
-                    
-                    DATA_FILES   = data_files,
-                    INSTALL_REQUIRES = [egg_qt4.egg_name()]
-                    )  
-                    
-class egg_boost(BaseEggBuilder):
-    license = "Boost Software License 1.0"
-    authors = "Boost contributors"
-    description = "Windows gcc libs and includes of Boost"    
-    py_dependent   = True
-    arch_dependent = True    
-    def script_substitutions(self):
-        version_re  = re_compile("^.*BOOST_VERSION\s:\s([\d\.]{4,8}).*$", re.MULTILINE|re.DOTALL)
-        boost_ = boost()
-                  
-        incs = recursive_glob_as_dict( boost_.install_inc_dir, Pattern.qtinc, strip_keys=True, prefix_key="include", dirs=True).items()
-        inc_dirs = merge_list_dict( incs )
-           
-        # get the version from Jamroot file
-        version = "UNKNOWN"        
-        with open( pj(boost_.sourcedir, "Jamroot") ) as f:
-            txt = f.read()
-            se = version_re.search(txt)
-            if se:
-                version = se.groups()[0]
-        lib_dirs    = {"lib": boost_.install_lib_dir}
-        
-        return dict( 
-                    VERSION          = version,                 
-                    LIB_DIRS         = lib_dirs,
-                    INC_DIRS         = inc_dirs,
-                    INSTALL_REQUIRES = [egg_mingw_rt.egg_name()]
-                    )  
-
-class egg_ann(BaseEggBuilder): 
-    license = "GNU Lesser Public License"
-    authors = "Copyright (c) 1997-2010 University of Maryland and Sunil Arya and David Mount"
-    description = "Windows gcc libs and includes of ANN"
-    py_dependent   = False
-    arch_dependent = True  
-    def script_substitutions(self):
-        ann_ = ann()
-        ann_path = ann_.sourcedir
-        
-        return dict( 
-                    VERSION          = ann_.version,                 
-                    LIB_DIRS         = {'lib' : pj(ann_path,'lib') },
-                    INC_DIRS         = {'include' : pj(ann_path,'include') },
-                    BIN_DIRS         = {'bin' : pj(ann_path,'bin') },
-                    DATA_FILES       = [('doc' , [pj(ann_path,'doc','ANNmanual.pdf')] )]
-                    ) 
-
-class egg_cgal(BaseEggBuilder): 
-    license = "GNU Lesser Public License"
-    authors = "CGAL, Computational Geometry Algorithms Library, http://www.cgal.org"
-    description = "Windows gcc libs and includes of CGAL"
-    py_dependent   = False
-    arch_dependent = True  
-    def script_substitutions(self):
-        cgal_ = cgal()
-        cgal_path = cgal_.sourcedir
-        
-        return dict( 
-                    VERSION          = cgal_.version,
-                    URL              = "http://www.cgal.org",
-                    LIB_DIRS         = {'lib' : pj(cgal_path,'lib') },
-                    INC_DIRS         = {'include' : pj(cgal_path,'include') },
-                    BIN_DIRS         = {'bin' : pj(cgal_path,'bin') },
-                    #DATA_FILES       = [('doc' , glob.glob(pj(cgal_path,'doc_html','*')) )]
-                    ) 
-
-# class egg_gnuplot(BaseEggBuilder): 
-    # license = "GNUPlot license"
-    # authors = "Copyright 1986 - 1993, 1998, 2004 Thomas Williams, Colin Kelley"
-    # description = "Windows gcc libs and includes of gnuplot"
-    # py_dependent   = False
-    # arch_dependent = True  
-   
-# class egg_qhull(BaseEggBuilder): 
-    # license = "GNUPlot license"
-    # authors = "Copyright (c) 1993-2011 C.B. Barber, Arlington, MA and The Geometry Center, University of Minnesota"
-    # description = "Windows gcc libs and includes of qhull"
-    # py_dependent   = False
-    # arch_dependent = True  
-   
-class egg_rpy2(BaseEggBuilder): 
-    license = "AGPLv3.0 (except rpy2.rinterface: LGPL)"
-    authors = "Laurent Gautier"
-    description = "Unofficial Windows gcc libs and includes of rpy2"
-    py_dependent   = True
-    arch_dependent = True
-    
-    def script_substitutions(self):
-        from setuptools import find_packages
-        rpy2_ = rpy2()
-        return dict(URL          = "http://rpy.sourceforge.net",
-                    PACKAGES     = find_packages(rpy2_.installdir,"rpy2"),
-                    PACKAGE_DIRS = { "rpy2": pj(rpy2_.installdir, "rpy2") },
-                    VERSION      = rpy2_.version+".rev"+rpy2_.revision,
-                    PACKAGE_DATA = {'' : [Pattern.pyext]},
-                    ) 
-
-    
-############################################################
-# The following egg builders require that you have the     #
-# corresponding library installed. This is because they    #
-# are too difficult to compile and that we don't actually  #
-# need to compile them (no linkage from us to them)        #
-# or that they come as .exes and not eggs already          #
-############################################################
-class egg_numpy(InstalledPackageEggBuilder):
-    license = "Numpy License"
-    authors = "(c) Numpy Developers"
-    description = "Numpy packaged as an egg"      
-    py_dependent   = True
-    arch_dependent = True    
-    def script_substitutions_2(self):
-        return dict( VERSION = self.package.version.full_version )
-        
-class egg_scipy(InstalledPackageEggBuilder):
-    license = "Scipy License"
-    authors = "(c) Enthought"
-    description = "Scipy packaged as an egg"  
-    py_dependent   = True
-    arch_dependent = True        
-    def script_substitutions_2(self):
-        return dict( VERSION = self.package.version.full_version )
-        
-class egg_matplotlib(InstalledPackageEggBuilder):
-    license = "Python Software Foundation License Derivative - BSD Compatible."
-    authors = "Matplotlib developers"
-    description = "Matplotlib packaged as an egg"  
-    py_dependent   = True
-    arch_dependent = True        
-    def script_substitutions_2(self):        
-        return dict( VERSION = self.package.__version__ )
-                                               
-class egg_PIL(InstalledPackageEggBuilder):
-    license = "PIL License."
-    authors = "Copyright (c) 1997-2011 by Secret Labs AB, Copyright (c) 1995-2011 by Fredrik Lundh."
-    description = "PIL packaged as an egg"  
-    __modulename__  = "Image"
-    py_dependent   = True
-    arch_dependent = True    
-    def script_substitutions_2(self):
-        return dict( VERSION = self.module.VERSION )
-                 
-class egg_pylsm(InstalledPackageEggBuilder):
-    license = "PYLSM License."
-    authors = "Freesbi.ch"
-    description = "Patched version of PyLSM"  
-    py_dependent   = True
-    arch_dependent = False
-    
-    @property 
-    @with_original_sys_path
-    def package(self):
-        return __import__(self.packagename)
-    
-    def script_substitutions_2(self):
-        pth = self.package.__path__[0]
-        version = "0.1-r34"
-        for p in pth.split("\\"):
-            if ".egg" in p:
-                version = p.split("-")[1]+"_1" # we have a patched version
-        return dict( VERSION = version )        
-        
-# class egg_pylibtiff(InstalledPackageEggBuilder):
-    # license = "BSD License."
-    # authors = "Pearu Peterson & friends."
-    # description = "Precompiled pylibtiff for Windows."  
-    # py_dependent   = True
-    # arch_dependent = False
+# -*- python -*-
+#
+#       openalea.deploy.dependency_builder
+#
+#       Copyright 2006-2012 INRIA - CIRAD - INRA
+#
+#       File author(s): Daniel Barbeau
+#       File Contributors(s):   
+#                             - Yassin Refahi,
+#                             - Frederic Boudon,
+#
+#       Distributed under the Cecill-C License.
+#       See accompanying file LICENSE.txt or copy at
+#           http://www.cecill.info/licences/Licence_CeCILL-C_V1-en.html
+#
+#       OpenAlea WebSite : http://openalea.gforge.inria.fr
+#
+###############################################################################
+
+################################################################################
+# - EGG BUILDERS - EGG BUILDERS - EGG BUILDERS - EGG BUILDERS - EGG BUILDERS - #
+# !!!!   THE ORDER OF CLASS DEFINITIONS IS THE ORDER OF EGG COMPILATION    !!!!#
+################################################################################        
+class egg_mingw_rt(BaseEggBuilder):
+    license = "PublicDomain for MingW runtime. GLP or LGPL for some libraries."
+    authors = "The Mingw Project"
+    description = "Mingw Development (compiler, linker, libs, includes)"
+    py_dependent   = False
+    arch_dependent = True
+    version        = "5.1.4_4b"
+    def script_substitutions(self):
+        mgw = mingwrt()
+        libdirs = {"bin":mgw.install_dll_dir}
+        return dict( 
+                    VERSION  = self.version,
+                    LIB_DIRS = libdirs,
+                    )                
+
+class egg_mingw(BaseEggBuilder):
+    license = "PublicDomain for MingW runtime. GLP or LGPL for some libraries."
+    authors = "The Mingw Project"
+    description = "Mingw Runtime"
+    py_dependent   = False
+    arch_dependent = True
+    def script_substitutions(self):
+        cpath = Compiler.get_bin_path()
+        mingwbase = pj(cpath,os.pardir)
+        subd  = os.listdir( mingwbase )
+        subd.remove("EGG-INFO")
+        subd.remove("bin")
+        subd.remove("include")
+        data = []
+        
+        for dir in subd:
+            dat = list(recursive_glob_as_dict(pj(mingwbase,dir), "*", strip_keys=True, prefix_key=dir).items())         
+            data += [ (d, [f for f in t if not f.endswith(".dll")]) for d,t in dat]
+
+        bindirs = {"bin": cpath}
+        incdirs = {"include": pj(mingwbase, "include")}
+            
+        return dict( 
+                    VERSION  = egg_mingw_rt.version,
+                    BIN_DIRS = bindirs,
+                    INC_DIRS = incdirs,
+                    DATA_FILES   = data,
+                    )  
+    
+class egg_qt4(BaseEggBuilder):
+    license = "General Public License V3"
+    authors = "Riverbank Computing (Sip+PyQt4+QSCintilla) & Nokia (Qt4)"
+    description = "Sip+PyQt4+QScintilla Runtime packaged as an egg for windows-gcc"
+    py_dependent   = True
+    arch_dependent = True
+    def script_substitutions(self):        
+        qt4_   = qt4()
+        pyqt4_ = pyqt4()
+        pysci_ = pyqscintilla()
+        sip_   = sip()
+        # dlls are the union of qt dlls and plugins directories (which is actually the same!)
+        # qscis apis are recursive from qt4 (need to list all files)        
+        qscis    = list(recursive_glob_as_dict(pysci_.qsci_dir, Pattern.sciapi, strip_keys=True, prefix_key="qsci").items())
+        extra_pyqt4_mods = list(recursive_glob_as_dict(pj(pyqt4_.install_site_dir,"PyQt4"), Pattern.pyall, strip_keys=True, prefix_key="PyQt4").items())
+        print("laaaaaaaaaaaaaaaajfdshfsdosfdo", extra_pyqt4_mods)
+        sip_mods = list(recursive_glob_as_dict(sip_.install_site_dir, Pattern.pyall, strip_keys=True, levels=1).items())
+
+        lib_dirs    = {"PyQt4": qt4_.install_dll_dir}
+        package_dir = {"PyQt4": pj(pyqt4_.install_site_dir, "PyQt4")}
+        
+        from openalea.vpltk.qt import QtCore
+        from setuptools import find_packages
+        return dict( 
+                    VERSION  = QtCore.QT_VERSION_STR,
+                    PACKAGES = find_packages(pyqt4_.install_site_dir, "PyQt4"),
+                    PACKAGE_DIRS = package_dir,
+                    PACKAGE_DATA = {'' : [Pattern.pyext]},
+                    
+                    LIB_DIRS         = lib_dirs,
+                    DATA_FILES       = qscis+sip_mods+extra_pyqt4_mods,
+                    INSTALL_REQUIRES = [egg_mingw_rt.egg_name()]
+                    )  
+                    
+class egg_qt4_dev(BaseEggBuilder):
+    license = "General Public License V3"
+    authors = "Riverbank Computing (Sip+PyQt4+QSCintilla) & Nokia (Qt4)"
+    description = "Sip+PyQt4+QScintilla Development packaged as an egg for windows-gcc"
+    py_dependent   = True
+    arch_dependent = True
+    def script_substitutions(self):
+        qt4_   = qt4()
+        pyqt4_ = pyqt4()
+        sip_   = sip()
+        # binaries are the union of qt, pyqt and sip binaries 
+        bin_dirs = {"bin":qt4_.install_bin_dir}
+        # includes are recursive subdirectories and the union of qt and sip includes               
+        incs = list(recursive_glob_as_dict( qt4_.install_inc_dir, Pattern.qtinc, strip_keys=True, prefix_key="include", dirs=True).items()) + \
+               list(recursive_glob_as_dict( sip_.install_inc_dir, Pattern.qtinc, strip_keys=True, prefix_key="include", dirs=True).items())
+        inc_dirs = merge_list_dict( incs )
+        # libs are recursive subdirectories of qt libs          
+        libs = list(recursive_glob_as_dict(qt4_.install_lib_dir, Pattern.qtstalib, strip_keys=True, prefix_key="lib").items())
+        # sip files are recursive subdirectories and the union of pyqt4 and...
+        sips = list(recursive_glob_as_dict(pyqt4_.install_sip_dir, Pattern.sipfiles, strip_keys=True, prefix_key="sip").items())
+        # sources are recursive subdirectories and the union of qt4 and that all (CPP have been removed)...
+        srcs = list(recursive_glob_as_dict(qt4_.install_src_dir, Pattern.qtsrc, strip_keys=True, prefix_key="src").items())
+        # tra files are recursive subdirectories in qt4
+        tra = list(recursive_glob_as_dict(qt4_.install_tra_dir, Pattern.qttransl, strip_keys=True, prefix_key="translations").items())
+        # mks files are recursive subdirectories in qt4
+        mks = list(recursive_glob_as_dict(qt4_.install_mks_dir, Pattern.qtmkspec, strip_keys=True, prefix_key="mkspecs").items())        
+        # plugins files are recursive subdirectories in qt4
+        plu = list(recursive_glob_as_dict(qt4_.install_plu_lib_dir, Pattern.qtstalib, strip_keys=True, prefix_key="plugins").items())        
+
+        from openalea.vpltk.qt import QtCore
+        
+        return dict( 
+                    VERSION          = QtCore.QT_VERSION_STR,                   
+                    BIN_DIRS         = bin_dirs,
+                    INC_DIRS         = inc_dirs,
+                    DATA_FILES       = libs+sips+srcs+tra+mks+plu,
+                    INSTALL_REQUIRES = [egg_qt4.egg_name()]
+                    )  
+                    
+class egg_pyqglviewer(BaseEggBuilder):
+    license = "General Public License"
+    authors = "libQGLViewer developers for libQGLViewer, PyQGLViewer (INRIA) developers for PyQGLViewer"
+    description = "Win-GCC version of PyQGLViewer"
+    py_dependent   = True
+    arch_dependent = True
+    def script_substitutions(self):
+        qt4_   = qt4()
+        qglv_   = qglviewer()
+        pyqglv_   = pyqglviewer()
+        
+        pyqgl_mods = list(recursive_glob_as_dict(pyqglv_.install_site_dir, Pattern.pyall, strip_keys=True, levels=1).items())
+        # includes are recursive subdirectories of qglviewer           
+        incs = list(recursive_glob_as_dict( qglv_.install_inc_dir, Pattern.include, strip_keys=True, prefix_key="include", dirs=True).items())
+        inc_dirs = merge_list_dict( incs )
+        # libs are recursive subdirectories of qt libs          
+        libs = list(recursive_glob_as_dict(qglv_.install_lib_dir, Pattern.qtstalib, strip_keys=True, prefix_key="lib").items())
+        # sip files are recursive subdirectories of pyqglviewer sip installation directory
+        sips = list(recursive_glob_as_dict(pyqglv_.install_sip_dir, Pattern.sipfiles, strip_keys=True, prefix_key="sip").items())
+        # examples are recursive subdirectories of pyqglviewer examples installation directory contains various types of files
+        exas = list(recursive_glob_as_dict(pyqglv_.install_exa_dir, Pattern.any, strip_keys=True, prefix_key="examples").items())        
+        
+        lib_dirs    = {"" : qglv_.install_dll_dir}
+        data_files  = exas+sips+libs+pyqgl_mods
+        
+        import PyQGLViewer
+        
+        return dict( 
+                    VERSION      = PyQGLViewer.QGLViewerVersionString(),                                  
+                    PACKAGE_DATA = {'' : [Pattern.pyext]},
+                    #PACKAGE_DIRS = package_dir,                    
+                    LIB_DIRS     = lib_dirs,
+                    INC_DIRS     = inc_dirs,
+                    
+                    DATA_FILES   = data_files,
+                    INSTALL_REQUIRES = [egg_qt4.egg_name()]
+                    )  
+                    
+class egg_boost(BaseEggBuilder):
+    license = "Boost Software License 1.0"
+    authors = "Boost contributors"
+    description = "Windows gcc libs and includes of Boost"    
+    py_dependent   = True
+    arch_dependent = True    
+    def script_substitutions(self):
+        version_re  = re_compile("^.*BOOST_VERSION\s:\s([\d\.]{4,8}).*$", re.MULTILINE|re.DOTALL)
+        boost_ = boost()
+                  
+        incs = list(recursive_glob_as_dict( boost_.install_inc_dir, Pattern.qtinc, strip_keys=True, prefix_key="include", dirs=True).items())
+        inc_dirs = merge_list_dict( incs )
+           
+        # get the version from Jamroot file
+        version = "UNKNOWN"        
+        with open( pj(boost_.sourcedir, "Jamroot") ) as f:
+            txt = f.read()
+            se = version_re.search(txt)
+            if se:
+                version = se.groups()[0]
+        lib_dirs    = {"lib": boost_.install_lib_dir}
+        
+        return dict( 
+                    VERSION          = version,                 
+                    LIB_DIRS         = lib_dirs,
+                    INC_DIRS         = inc_dirs,
+                    INSTALL_REQUIRES = [egg_mingw_rt.egg_name()]
+                    )  
+
+class egg_ann(BaseEggBuilder): 
+    license = "GNU Lesser Public License"
+    authors = "Copyright (c) 1997-2010 University of Maryland and Sunil Arya and David Mount"
+    description = "Windows gcc libs and includes of ANN"
+    py_dependent   = False
+    arch_dependent = True  
+    def script_substitutions(self):
+        ann_ = ann()
+        ann_path = ann_.sourcedir
+        
+        return dict( 
+                    VERSION          = ann_.version,                 
+                    LIB_DIRS         = {'lib' : pj(ann_path,'lib') },
+                    INC_DIRS         = {'include' : pj(ann_path,'include') },
+                    BIN_DIRS         = {'bin' : pj(ann_path,'bin') },
+                    DATA_FILES       = [('doc' , [pj(ann_path,'doc','ANNmanual.pdf')] )]
+                    ) 
+
+class egg_cgal(BaseEggBuilder): 
+    license = "GNU Lesser Public License"
+    authors = "CGAL, Computational Geometry Algorithms Library, http://www.cgal.org"
+    description = "Windows gcc libs and includes of CGAL"
+    py_dependent   = False
+    arch_dependent = True  
+    def script_substitutions(self):
+        cgal_ = cgal()
+        cgal_path = cgal_.sourcedir
+        
+        return dict( 
+                    VERSION          = cgal_.version,
+                    URL              = "http://www.cgal.org",
+                    LIB_DIRS         = {'lib' : pj(cgal_path,'lib') },
+                    INC_DIRS         = {'include' : pj(cgal_path,'include') },
+                    BIN_DIRS         = {'bin' : pj(cgal_path,'bin') },
+                    #DATA_FILES       = [('doc' , glob.glob(pj(cgal_path,'doc_html','*')) )]
+                    ) 
+
+# class egg_gnuplot(BaseEggBuilder): 
+    # license = "GNUPlot license"
+    # authors = "Copyright 1986 - 1993, 1998, 2004 Thomas Williams, Colin Kelley"
+    # description = "Windows gcc libs and includes of gnuplot"
+    # py_dependent   = False
+    # arch_dependent = True  
+   
+# class egg_qhull(BaseEggBuilder): 
+    # license = "GNUPlot license"
+    # authors = "Copyright (c) 1993-2011 C.B. Barber, Arlington, MA and The Geometry Center, University of Minnesota"
+    # description = "Windows gcc libs and includes of qhull"
+    # py_dependent   = False
+    # arch_dependent = True  
+   
+class egg_rpy2(BaseEggBuilder): 
+    license = "AGPLv3.0 (except rpy2.rinterface: LGPL)"
+    authors = "Laurent Gautier"
+    description = "Unofficial Windows gcc libs and includes of rpy2"
+    py_dependent   = True
+    arch_dependent = True
+    
+    def script_substitutions(self):
+        from setuptools import find_packages
+        rpy2_ = rpy2()
+        return dict(URL          = "http://rpy.sourceforge.net",
+                    PACKAGES     = find_packages(rpy2_.installdir,"rpy2"),
+                    PACKAGE_DIRS = { "rpy2": pj(rpy2_.installdir, "rpy2") },
+                    VERSION      = rpy2_.version+".rev"+rpy2_.revision,
+                    PACKAGE_DATA = {'' : [Pattern.pyext]},
+                    ) 
+
+    
+############################################################
+# The following egg builders require that you have the     #
+# corresponding library installed. This is because they    #
+# are too difficult to compile and that we don't actually  #
+# need to compile them (no linkage from us to them)        #
+# or that they come as .exes and not eggs already          #
+############################################################
+class egg_numpy(InstalledPackageEggBuilder):
+    license = "Numpy License"
+    authors = "(c) Numpy Developers"
+    description = "Numpy packaged as an egg"      
+    py_dependent   = True
+    arch_dependent = True    
+    def script_substitutions_2(self):
+        return dict( VERSION = self.package.version.full_version )
+        
+class egg_scipy(InstalledPackageEggBuilder):
+    license = "Scipy License"
+    authors = "(c) Enthought"
+    description = "Scipy packaged as an egg"  
+    py_dependent   = True
+    arch_dependent = True        
+    def script_substitutions_2(self):
+        return dict( VERSION = self.package.version.full_version )
+        
+class egg_matplotlib(InstalledPackageEggBuilder):
+    license = "Python Software Foundation License Derivative - BSD Compatible."
+    authors = "Matplotlib developers"
+    description = "Matplotlib packaged as an egg"  
+    py_dependent   = True
+    arch_dependent = True        
+    def script_substitutions_2(self):        
+        return dict( VERSION = self.package.__version__ )
+                                               
+class egg_PIL(InstalledPackageEggBuilder):
+    license = "PIL License."
+    authors = "Copyright (c) 1997-2011 by Secret Labs AB, Copyright (c) 1995-2011 by Fredrik Lundh."
+    description = "PIL packaged as an egg"  
+    __modulename__  = "Image"
+    py_dependent   = True
+    arch_dependent = True    
+    def script_substitutions_2(self):
+        return dict( VERSION = self.module.VERSION )
+                 
+class egg_pylsm(InstalledPackageEggBuilder):
+    license = "PYLSM License."
+    authors = "Freesbi.ch"
+    description = "Patched version of PyLSM"  
+    py_dependent   = True
+    arch_dependent = False
+    
+    @property 
+    @with_original_sys_path
+    def package(self):
+        return __import__(self.packagename)
+    
+    def script_substitutions_2(self):
+        pth = self.package.__path__[0]
+        version = "0.1-r34"
+        for p in pth.split("\\"):
+            if ".egg" in p:
+                version = p.split("-")[1]+"_1" # we have a patched version
+        return dict( VERSION = version )        
+        
+# class egg_pylibtiff(InstalledPackageEggBuilder):
+    # license = "BSD License."
+    # authors = "Pearu Peterson & friends."
+    # description = "Precompiled pylibtiff for Windows."  
+    # py_dependent   = True
+    # arch_dependent = False
diff --git a/src/openalea/deploy/system_dependencies/patch.py b/src/openalea/deploy/system_dependencies/patch.py
index 01451da..f46aa4a 100644
--- a/src/openalea/deploy/system_dependencies/patch.py
+++ b/src/openalea/deploy/system_dependencies/patch.py
@@ -19,8 +19,8 @@ import copy
 import logging
 import re
 # cStringIO doesn't support unicode in 2.5
-from StringIO import StringIO
-import urllib2
+from io import StringIO
+import urllib.request, urllib.error, urllib.parse
 
 from os.path import exists, isfile, abspath
 from os import unlink
@@ -70,7 +70,7 @@ def fromstring(s):
 def fromurl(url):
   """ Read patch from URL
   """
-  return Patch( urllib2.urlopen(url) )
+  return Patch( urllib.request.urlopen(url) )
 
 
 class Hunk(object):
@@ -155,14 +155,14 @@ class Patch(object):
         self._lineno = False     # after end of stream equal to the num of lines
         self._line = False       # will be reset to False after end of stream
 
-      def next(self):
+      def __next__(self):
         """Try to read the next line and return True if it is available,
            False if end of stream is reached."""
         if self._exhausted:
           return False
 
         try:
-          self._lineno, self._line = super(wrapumerate, self).next()
+          self._lineno, self._line = next(super(wrapumerate, self))
         except StopIteration:
           self._exhausted = True
           self._line = False
@@ -198,7 +198,7 @@ class Patch(object):
     # start of main cycle
     # each parsing block already has line available in fe.line
     fe = wrapumerate(stream)
-    while fe.next():
+    while next(fe):
 
       # -- deciders: these only switch state to decide who should process
       # --           line fetched at the start of this cycle
@@ -217,7 +217,7 @@ class Patch(object):
         header = ''
         while not fe.is_empty and not fe.line.startswith("--- "):
             header += fe.line
-            fe.next()
+            next(fe)
         if fe.is_empty:
             if len(self.source) == 0:
               warning("warning: no patch data is found")
diff --git a/src/openalea/deploy/system_dependencies/project_rules.py b/src/openalea/deploy/system_dependencies/project_rules.py
index b7c33da..8a6fe25 100644
--- a/src/openalea/deploy/system_dependencies/project_rules.py
+++ b/src/openalea/deploy/system_dependencies/project_rules.py
@@ -1,618 +1,618 @@
-# -*- python -*-
-#
-#       openalea.deploy.dependency_builder
-#
-#       Copyright 2006-2012 INRIA - CIRAD - INRA
-#
-#       File author(s): Daniel Barbeau
-#       File Contributors(s):   
-#                             - Yassin Refahi,
-#                             - Frederic Boudon,
-#
-#       Distributed under the Cecill-C License.
-#       See accompanying file LICENSE.txt or copy at
-#           http://www.cecill.info/licences/Licence_CeCILL-C_V1-en.html
-#
-#       OpenAlea WebSite : http://openalea.gforge.inria.fr
-#
-###############################################################################
-
-####################################################################################################
-# - PROJECT BUILDERS - PROJECT BUILDERS - PROJECT BUILDERS - PROJECT BUILDERS - PROJECT BUILDERS - #
-# !!!!          THE ORDER OF CLASS DEFINITIONS IS THE ORDER OF PROJECT COMPILATION             !!!!#
-####################################################################################################
-class mingwrt(BaseProjectBuilder):
-    url = None
-    supported_tasks = "i"
-    download_name  = "mingw"
-    archive_subdir = None
-    def __init__(self, *args, **kwargs):
-        BaseProjectBuilder.__init__(self, *args, **kwargs)
-        self.sourcedir = pj(Compiler.get_bin_path(), os.pardir)
-        self.install_dll_dir = pj(self.installdir, "dll")
-
-    def install(self):
-        recursive_copy( pj(self.sourcedir, "bin"), self.install_dll_dir, Pattern.dynlib, levels=1)
-        return True
-
-
-
-class qt4(BaseProjectBuilder):
-    version = "4.7.4"
-    #version = "4.8.0"
-    url = "http://get.qt.nokia.com/qt/source/qt-everywhere-opensource-src-"+version+".zip"
-    download_name  = "qt4_src.zip"
-    archive_subdir = "qt-every*"
-
-    def __init__(self, *args, **kwargs):
-        BaseProjectBuilder.__init__(self, *args, **kwargs)
-        # define installation paths
-        self.install_bin_dir = pj(self.installdir, "bin")
-        self.install_dll_dir = pj(self.installdir, "dll")
-        self.install_lib_dir = pj(self.installdir, "lib")
-        self.install_src_dir = pj(self.installdir, "src")
-        self.install_inc_dir = pj(self.installdir, "include")
-        self.install_plu_dir = pj(self.installdir, "dll")
-        self.install_plu_lib_dir = pj(self.installdir, "plugins_lib")
-        self.install_mks_dir = pj(self.installdir, "mkspecs")
-        self.install_tra_dir = pj(self.installdir, "translations")
-        self.inst_paths = [getattr(self, attr) for attr in dir(self) if attr.startswith("install_")\
-                           and attr.endswith("_dir")]
-
-    def new_env_vars(self):
-        if Compiler.version_gt("4.6.0"):
-            return [ ("QMAKESPEC","win32-g++-4.6") ]
-        else:
-            return [ ("QMAKESPEC","win32-g++") ]
-
-    def configure(self):
-        # we must rename syncqt[.bat] files in the bin directory if they exist.
-        syncqtfiles = recursive_glob( "bin", "syncqt*")
-        for sqt in syncqtfiles:
-            os.rename(sqt, sqt+"_no_use")
-            
-        # we must patch the sources in some cases
-        if self.version == "4.8.0" :#and Compiler.version_gt("4.7.0"):
-            apply_patch(  pj(ModuleBaseDir,"qt-4.8.0.patch") )
-            
-        # build the configure command line
-        common = " -release -opensource -shared -nomake demos -nomake examples -mmx -sse2 -3dnow"
-        common += " -declarative -webkit -no-s60 -no-cetest"        
-        cmd = "configure.exe" + common
-        if Compiler.version_gt("4.6.0"):
-            # TDM doesn't ship with DirectX headers. Cannot use Phonon
-            # Actually this is useless as configure.exe will check himself.
-            cmd += " -no-phonon" #  + " -no-declarative"
-        # PIPE is required or else pop.communicate won't do anything!
-        pop = subprocess.Popen(cmd, stdin=subprocess.PIPE)
-        # give enough time for executable to load before it asks for license agreement.
-        time.sleep(2)
-        # accepts license agreement, also waits for configure to finish
-        pop.communicate("y\r")
-        return pop.returncode == 0
-
-    def install(self):
-        # create the installation directories
-        for pth in self.inst_paths:
-            makedirs(pth)
-        # copy binaries
-        recursive_copy( pj(self.sourcedir, "bin"), self.install_bin_dir, Pattern.exe )
-        # add a qt.conf file that tells qmake to look into
-        # directories that are relative to the executable.
-        with open( pj(self.install_bin_dir, "qt.conf"), "w") as qtconf:
-            qtconf.write("[Paths]")
-        # copy dlls
-        recursive_copy( pj(self.sourcedir, "bin"), self.install_dll_dir, Pattern.dynlib )
-        # copy libs
-        recursive_copy( pj(self.sourcedir, "lib"), self.install_lib_dir, Pattern.qtstalib )
-        # copy src -- actually only header files in src --
-        recursive_copy( pj(self.sourcedir, "src"), self.install_src_dir, Pattern.qtsrc )
-        # copy include
-        recursive_copy( pj(self.sourcedir, "include"), self.install_inc_dir, Pattern.qtinc )
-        # copy plugins
-        recursive_copy( pj(self.sourcedir, "plugins"), self.install_plu_dir, Pattern.dynlib, flat=True )
-        # copy plugins
-        recursive_copy( pj(self.sourcedir, "plugins"), self.install_plu_lib_dir, Pattern.qtstalib )
-        # copy plugins
-        recursive_copy( pj(self.sourcedir, "mkspecs"), self.install_mks_dir, Pattern.qtmkspec )
-        # copy translations
-        recursive_copy( pj(self.sourcedir, "translations"), self.install_tra_dir, Pattern.qttransl )
-        self.make_qt_conf()
-        return True
-
-    def extra_paths(self):
-        return pj(self.sourcedir, "bin")
-
-    def make_qt_conf(self, where=None):
-        """ Patch qt *.exes and *.dlls so that they do not contain hard coded paths anymore. """
-        config = ConfigParser.RawConfigParser()
-        sec = "Paths"
-        config.add_section(sec)
-        if where == None:
-            config.set(sec, "Headers",	 "../include")
-            config.set(sec, "Libraries", "../lib")
-            config.set(sec, "Binaries",  "../bin")
-            config.set(sec, "Plugins",   "../dll")
-            #config.set(sec, "Imports"	"no idea")
-            config.set(sec, "Data",      "..")
-            config.set(sec, "Translations", "../translations")
-        else:
-            unix_installdir = self.installdir.replace("\\", "/")
-            config.set(sec, "Headers",	 uj(unix_installdir, "include"))
-            config.set(sec, "Libraries", uj(unix_installdir, "lib"))
-            config.set(sec, "Binaries",  uj(unix_installdir, "bin"))
-            config.set(sec, "Plugins",   uj(unix_installdir, "dll"))
-            #config.set(sec, "Imports"	"no idea")
-            config.set(sec, "Data",      unix_installdir )
-            config.set(sec, "Translations", uj(unix_installdir, "translations")  )      
-        # Writing our configuration file
-        if where is None:
-            where = self.install_bin_dir
-        with open(pj(where, 'qt.conf'), 'w') as configfile:
-            config.write(configfile)
-        return True
-
-
-
-class sip(BaseProjectBuilder):
-    url = "http://www.riverbankcomputing.com/hg/sip/archive/0869eb93c773.zip" #downloading from the mercurial tag
-    #url = "http://www.riverbankcomputing.co.uk/static/Downloads/sip4/sip-4.13.2.zip"
-    download_name  = "sip_src.zip"
-    archive_subdir = "sip*"
-    
-    required_tools = [bisonflex]
-
-    def __init__(self, *args, **kwargs):
-        BaseProjectBuilder.__init__(self, *args, **kwargs)
-        # we install pyqt4 binaries in the qt bin installation directory to easily recover it
-        # for the egg. The eggs are built in the historical layout used by openalea packagers.
-        # This doesn't mean it's good. It doesn't mean it's bad though it does look a bit messy.
-        qt4_ = qt4()
-        self.install_bin_dir  = qt4_.install_bin_dir
-        self.install_site_dir = pj(self.installdir, "site")
-        self.install_inc_dir  = pj(self.installdir, "include")
-        self.install_sip_dir  = pj(self.installdir, "sip")
-
-        self.inst_paths = self.install_bin_dir, self.install_site_dir, self.install_inc_dir, \
-                          self.install_sip_dir
-
-    @option_to_sys_path("bisonflex_path")
-    def configure(self):
-        if exists(pj(self.sourcedir,"configure.py") ):
-            print "it's alive!"
-            # The -S flag is needed or else configure.py
-            # sees any existing sip installation and can fail.
-            return subprocess.call(sys.executable + \
-                   " -S configure.py --platform=win32-g++ -b %s -d %s -e %s -v %s"%self.inst_paths) == 0
-        else:
-            #if configure.py doesn't exist then we might
-            #be using a zipball retreived directly from
-            #sip's mercurial repository. This type of source
-            #needs a step before actually calling configure.py
-            if exists("build.py"):
-                print "Will try to build sip from mercurial source zipball"
-                try:
-                    #We neeeed bison and flex
-                    subprocess.call("bison.exe")
-                except:
-                    print "Could not find bison flex, use --bisonflex"
-                    return False
-                apply_patch( pj(ModuleBaseDir,"sip_build.patch") )
-                subprocess.call(sys.executable + " -S build.py prepare")
-                return self.configure()
-            else:
-                #we don't have a clue of what type of source we're in
-                #so dying cleanly can seem like a good option:
-                return False
-
-    def extra_paths(self):
-        return self.sourcedir, pj(self.sourcedir, "sipgen")
-
-    def extra_python_paths(self):
-        return self.sourcedir, pj(self.sourcedir, "siplib")
-
-    def patch(self):
-        return True
-        # Patching sipconfig.py so that its
-        # paths point to the qt4 egg path we are building.
-        # Feel free to do better
-        header = """
-import re
-from os.path import join as pj
-from pkg_resources import Environment
-
-# Default Path.
-qtdev = os.environ.get('QTDIR') if 'QTDIR' in os.environ else 'C:\\Qt\\4.6.0'
-sip_bin     = pj(sys.prefix,'sip')
-sip_include = pj(sys.prefix, 'include')
-env = Environment()
-if 'qt4' in env:
-    qt = env['qt4'][0].location # Warning: 0 is the active one
-if 'qt4-dev' in env:
-    qtdev       = env['qt4-dev'][0].location # Warning: 0 is the active one
-    sip_bin     = pj(qtdev,'bin','sip.exe')
-    sip_include = pj(qtdev, 'include')
-    """
-
-        txt = ""
-        print "sip patching", os.getcwd()
-        with open("sipconfig.py") as f:
-            txt = f.read()
-
-        # inject our new header
-        txt = txt.replace("import re", header)
-
-        prefix = sys.prefix.replace("\\", r"\\\\")
-        # Evil massive regexp substitutions. RegExp are self-explanatory! Just kidding...
-        txt = re.sub(r"(\s*'default_bin_dir':\s*)'%s'"%prefix,    r"\1sys.prefix", txt)
-        txt = re.sub(r"(\s*'default_mod_dir':\s*)'%s.*'"%prefix,  r"\1pj(sys.prefix,'Lib\site-packages')", txt)
-        txt = re.sub(r"(\s*'default_sip_dir':\s*)'[A-Z]:\\\\.*'", r"\1pj(qtdev,'sip')", txt)
-        txt = re.sub(r"(\s*'py_conf_inc_dir':\s*)'%s.*'"%prefix,  r"\1pj(sys.prefix,'include')", txt)
-        txt = re.sub(r"(\s*'py_inc_dir':\s*)'%s.*'"%prefix,       r"\1pj(sys.prefix,'include')", txt)
-        txt = re.sub(r"(\s*'py_lib_dir':\s*)'%s.*'"%prefix,       r"\1pj(sys.prefix,'libs')", txt)
-        txt = re.sub(r"(\s*'sip_bin':\s*)'[A-Z]:\\\\.*'",         r"\1sip_bin", txt)
-        txt = re.sub(r"(\s*'sip_inc_dir':\s*)'[A-Z]:\\\\.*'",     r"\1sip_include", txt)
-        txt = re.sub(r"(\s*'sip_mod_dir':\s*)'[A-Z]:\\\\.*'",     r"\1qt", txt)
-
-        shutil.copyfile( "sipconfig.py", "sipconfig.py.old" )
-        with open( pj(self.install_site_dir,"sipconfig.py"), "w") as f:
-            f.write(txt)
-
-        return True
-
-
-
-class pyqt4(BaseProjectBuilder) :
-    url = "http://pypi.python.jp/PyQt/PyQt-win-gpl-4.8.6.zip#md5=734bb1b8e6016866f4450211fc4770d9"
-    #url = "http://www.riverbankcomputing.co.uk/static/Downloads/PyQt4/PyQt-win-gpl-4.9.1.zip"
-    download_name  = "pyqt4_src.zip"
-    archive_subdir = "PyQt*"
-    
-    cmd_options = [ ("siphome", None, "Path to sip.exe"),
-                    ("sipsite", None, "Path(s) to sip modules (';' seperated)") ]
-
-    def __init__(self, *args, **kwargs):
-        BaseProjectBuilder.__init__(self, *args, **kwargs)
-        # we install pyqt4 binaries in the qt bin installation directory to easily recover it
-        # for the egg. The eggs are built in the historical layout used by openalea packagers.
-        # This doesn't mean it's good. It doesn't mean it's bad though it does look a bit messy.
-        qt4_ = qt4()
-        self.install_bin_dir  = qt4_.install_bin_dir
-        self.install_site_dir = pj(self.installdir,"site")
-        self.install_sip_dir  = pj(self.installdir,"sip")
-        self.inst_paths       = self.install_bin_dir, self.install_site_dir, self.install_sip_dir
-
-    @option_to_python_path("sipsite")
-    @option_to_sys_path("siphome")
-    def configure(self):
-        # The -S flag is needed or else configure.py
-        # sees any existing sip installation and can fail.
-        # subprocess.call(sys.executable + \
-                      # " -S configure.py --help")
-        # return False
-        qt4_ = qt4()
-        #qtconf_dir = pj(self.sourcedir.replace("\\", "/"),"release")
-        #makedirs( qtconf_dir )
-        #qt4_.make_qt_conf(where=qtconf_dir)
-        return subprocess.call(sys.executable + \
-                      " -S configure.py --confirm-license -w -b %s -d %s -v %s"%self.inst_paths) == 0
-
-    def extra_paths(self):
-        return self.install_bin_dir
-
-    def extra_python_paths(self):
-        return self.install_site_dir
-
-    def patch(self):
-        return True
-        header = """
-import sipconfig
-from sipconfig import pj as pj
-from sipconfig import qtdev as qtdev
-from sipconfig import qt as qt"""
-
-        txt = ""
-        with open("pyqtconfig.py") as f:
-            txt = f.read()
-
-        txt = txt.replace("import sipconfig", header)
-        txt = re.sub(r"(\s*'pyqt_bin_dir':\s*)'[A-Z]:(\\\\|/).*'", r"\1pj(qtdev,'bin')", txt)
-        txt = re.sub(r"(\s*'pyqt_mod_dir':\s*)'[A-Z]:(\\\\|/).*'", r"\1pj(qt,'PyQt4')", txt)
-        txt = re.sub(r"(\s*'pyqt_sip_dir':\s*)'[A-Z]:(\\\\|/).*'", r"\1pj(qtdev,'sip')", txt)
-        txt = re.sub(r"(\s*'qt_data_dir':\s*)'[A-Z]:(\\\\|/).*'",  r"\1qtdev.replace('\\','/')", txt)
-        txt = re.sub(r"(\s*'qt_dir':\s*)'[A-Z]:(\\\\|/).*'",       r"\1qt", txt)
-        txt = re.sub(r"(\s*'qt_inc_dir':\s*)'[A-Z]:(\\\\|/).*'",   r"\1pj(qtdev, 'include')", txt)
-        txt = re.sub(r"(\s*'qt_lib_dir':\s*)'[A-Z]:(\\\\|/).*'",   r"\1pj(qtdev, 'lib')", txt)
-
-        txt = re.sub(r"(\s*'INCDIR_QT':\s*)'[A-Z]:(\\\\|/).*'",    r"\1pj(qtdev, 'include')", txt)
-        txt = re.sub(r"(\s*'LIBDIR_QT':\s*)'[A-Z]:(\\\\|/).*'",    r"\1pj(qtdev, 'lib')", txt)
-        txt = re.sub(r"(\s*'MOC':\s*)'[A-Z]:(\\\\|/).*'",          r"\1pj(qtdev, 'bin', 'moc.exe')", txt)
-
-        shutil.copyfile( "pyqtconfig.py", "pyqtconfig.py.old" )
-        with open("pyqtconfig.py", "w") as f:
-            f.write(txt)
-        prefix = sys.prefix
-
-
-
-class qscintilla(BaseProjectBuilder):
-    url = "http://www.riverbankcomputing.co.uk/static/Downloads/QScintilla2/QScintilla-gpl-2.6.1.zip"
-    download_name  = "qscintilla_src.zip"
-    archive_subdir = "QScint*/Qt4"
-
-    def configure(self):
-        # The install procedure will install qscintilla in qt's installation directories
-        qt4_ = qt4()
-        paths = qt4_.install_inc_dir, qt4_.install_tra_dir, qt4_.installdir, qt4_.install_dll_dir,
-        return subprocess.call( ("qmake -after header.path=%s trans.path=%s qsci.path=%s " + \
-                                 "target.path=%s -spec win32-g++ qscintilla.pro")%paths) == 0
-    def install(self):
-        ret = BaseProjectBuilder.install(self)
-        qt4_ = qt4()
-        try:
-            shutil.move( pj(qt4_.install_dll_dir, "libqscintilla2.a"), qt4_.install_lib_dir)
-        except Exception, epyqt :
-            print e
-        return ret
-
-
-
-class pyqscintilla(BaseProjectBuilder):
-    url = None # shares the same as qscintilla
-    download_name  = "qscintilla_src.zip"
-    archive_subdir = "QScint*/Python"
-
-    def __init__(self, *args, **kwargs):
-        BaseProjectBuilder.__init__(self, *args, **kwargs)
-        # define installation paths
-        qsci = qscintilla()
-        qt4_ = qt4()
-        pyqt = pyqt4()
-        self.install_paths = pj(qsci.sourcedir,"release"), pj(qt4_.installdir, "qsci"), \
-                             qsci.sourcedir, pj(pyqt.install_site_dir, "PyQt4"), \
-                             pyqt.install_sip_dir
-        self.qsci_dir = self.install_paths[1]
-
-    def configure(self):
-        # we want pyqscintilla to install itself where pyqt4 installed itself.
-        # -- The -S flag is needed or else configure.py
-        # sees any existing sip installation and can fail. --
-        return subprocess.call(sys.executable + \
-               " -S configure.py -o %s -a %s -n %s -d %s -v %s"%self.install_paths ) == 0
-
-
-
-class qglviewer(BaseProjectBuilder):
-    url = "https://gforge.inria.fr/frs/download.php/28138/libQGLViewer-2.3.9-py.tgz"
-    download_name  = "qglviewer_src.tgz"
-    archive_subdir = "libQGLV*/QGLViewer"
-
-    def __init__(self, *args, **kwargs):
-        BaseProjectBuilder.__init__(self, *args, **kwargs)
-        self.install_inc_dir = pj(self.installdir, "include", "QGLViewer")
-        self.install_dll_dir = pj(self.installdir, "dll")
-        self.install_lib_dir = pj(self.installdir, "lib")
-
-    def configure(self):
-        return subprocess.call("qmake QGLViewer*.pro") == 0
-
-    def build(self):
-        # by default, and since we do not use self.options yet, we build in release mode
-        return subprocess.call("mingw32-make release") == 0
-
-    def install(self):
-        # The install procedure will install qscintilla in qt's directories
-        recursive_copy( self.sourcedir               , self.install_inc_dir, Pattern.include)
-        recursive_copy( pj(self.sourcedir, "release"), self.install_lib_dir, Pattern.qtstalib)
-        recursive_copy( pj(self.sourcedir, "release"), self.install_dll_dir, Pattern.dynlib)
-        return True
-
-    def extra_paths(self):
-        return self.install_dll_dir
-
-
-
-class pyqglviewer(BaseProjectBuilder):
-    url = "https://gforge.inria.fr/frs/download.php/28212/PyQGLViewer-0.9.1.zip"
-    download_name  = "pyqglviewer_src.zip"
-    archive_subdir = "PyQGLV*"
-
-    def __init__(self, *args, **kwargs):
-        BaseProjectBuilder.__init__(self, *args, **kwargs)
-        qglbuilder = qglviewer()
-        self.qglbuilderbase = pj(qglbuilder.sourcedir, os.path.pardir),
-        self.install_sip_dir  = pj(qglbuilder.installdir, "sip")
-        self.install_site_dir = qglbuilder.installdir
-        self.install_exa_dir  = pj(qglbuilder.installdir, "examples")
-
-    def configure(self):
-        # The -S flag is needed or else configure.py
-        # sees any existing sip installation and can fail.
-        return subprocess.call(sys.executable + " -S configure.py -Q %s "%self.qglbuilderbase) == 0
-
-    def install(self):
-        """ pyqglviewer installs itself into the same directory as qglviewer """
-        recursive_copy( pj(self.sourcedir, "build"), self.install_site_dir, Pattern.pyext, levels=1)
-        recursive_copy( pj(self.sourcedir, "src", "sip"), self.install_sip_dir, Pattern.sipfiles, levels=1)
-        recursive_copy( pj(self.sourcedir, "examples"), self.install_exa_dir, Pattern.any)
-        return True
-
-    def extra_python_paths(self):
-        qglbuilder = qglviewer()
-        return qglbuilder.installdir
-
-
-
-class boost(BaseProjectBuilder):
-    url = "http://switch.dl.sourceforge.net/project/boost/boost/1.48.0/boost_1_48_0.zip"
-    download_name  = "boost_src.zip"
-    archive_subdir = "boost*"
-
-    def __init__(self, *args, **kwargs):
-        BaseProjectBuilder.__init__(self, *args, **kwargs)
-        self.install_inc_dir = pj(self.installdir, "include")
-        self.install_lib_dir = pj(self.installdir, "lib")
-
-    def configure(self):
-        return True #bjam configures, builds and installs so nothing to do here
-
-    def build(self):
-        # it is possible to bootstrap boost if no bjam.exe is found:
-        if not exists( pj(self.sourcedir, "bjam.exe") ):
-            print "Call bootstrap.bat"
-            if subprocess.call("bootstrap.bat mingw") != 0:
-                return False
-            else:
-                # The Bootstrapper top-level script ignores that gcc
-                # was used and by default says it's msvc, even though
-                # the lower level scripts used gcc.
-                ascii_file_replace( "project-config.jam",
-                                    "using msvc",
-                                    "using gcc")
-
-        # try to fix a bug in python discovery which prevents
-        # bjam from finding python on Windows NT and old versions.
-        pyjam_pth = pj("tools","build","v2","tools","python.jam")
-        ascii_file_replace(pyjam_pth,
-                           "[ version.check-jam-version 3 1 17 ] || ( [ os.name ] != NT )",
-                           "[ version.check-jam-version 3 1 17 ] && ( [ os.name ] != NT )")
-
-        paths = self.installdir, pj(sys.prefix, "include"), pj(sys.prefix,"libs")
-        cmd = "bjam --debug-configuration --prefix=%s --without-test --layout=system"
-        cmd += " variant=release link=shared threading=multi runtime-link=shared toolset=gcc"
-        cmd += " include=%s library-path=%s install"
-        cmd %= paths
-        print cmd
-        return subprocess.call(cmd) == 0
-
-    def install(self):
-        """ bjam configures, builds and installs so nothing to do here"""
-        return self.build()
-
-        
-        
-class ann(BaseProjectBuilder):
-    version = '1.1.2'
-    url = "http://www.cs.umd.edu/~mount/ANN/Files/"+version+"/ann_"+version+".zip"
-    download_name  = "ann_src.zip"
-    archive_subdir = "ann*"
-    enabled = True
-
-    def __init__(self, *args, **kwargs):
-        BaseProjectBuilder.__init__(self, *args, **kwargs)
-        self.patchfile = pj(ModuleBaseDir,"ann_mgw.patch")
-        self.install_inc_dir = pj(self.sourcedir, "include")
-        self.install_lib_dir = pj(self.sourcedir, "lib")
-        
-    def configure(self):
-        apply_patch(self.patchfile)
-        return True
-
-    def build(self):
-        return subprocess.call("mingw32-make win32-g++") == 0
-
-    def install(self):
-        return True
-
-
-
-class gnuplot(BaseProjectBuilder):
-    url = "http://heanet.dl.sourceforge.net/project/gnuplot/gnuplot/4.4.4/gp444win32.zip"
-    download_name  = "gnuplot_src.zip"
-    archive_subdir = "gnuplot*"
-    enabled = False
-
-    def __init__(self, *args, **kwargs):
-        BaseProjectBuilder.__init__(self, *args, **kwargs)
-        self.install_inc_dir = pj(self.installdir, "include")
-        self.install_lib_dir = pj(self.installdir, "lib")
-    def configure(self):
-        return True
-
-    def build(self):
-        return True
-
-    def install(self):
-        return True
-
-
-
-class qhull(BaseProjectBuilder):
-    url = "http://www.qhull.org/download/qhull-2011.2.zip"
-    download_name  = "qhull_src.zip"
-    archive_subdir = "qhull*"
-    enabled = False
-
-    def __init__(self, *args, **kwargs):
-        BaseProjectBuilder.__init__(self, *args, **kwargs)
-        self.install_inc_dir = pj(self.installdir, "include")
-        self.install_lib_dir = pj(self.installdir, "lib")
-    
-    def configure(self):
-        return True
-
-    def build(self):
-        return True
-    
-    def install(self):
-        return True
-
-        
-        
-class cgal(BaseProjectBuilder):
-    url = "https://gforge.inria.fr/frs/download.php/30390/CGAL-4.0.zip"
-    download_name  = "cgal_src.zip"
-    archive_subdir = "cgal*"
-    required_tools = [cmake]
-    enabled = True
-    version = "4.0"
-    def __init__(self, *args, **kwargs):
-        BaseProjectBuilder.__init__(self, *args, **kwargs)
-        self.install_inc_dir = pj(self.installdir, "include")
-        self.install_lib_dir = pj(self.installdir, "lib")
-    
-    def configure(self):
-        compiler = Compiler.get_bin_path()
-        boost_ = boost()
-        
-        db_quote = lambda x: '"'+x+'"'
-        
-        options = " ".join(['-DCMAKE_INSTALL_PREFIX='+db_quote(self.installdir),
-                            '-DCMAKE_CXX_COMPILER:FILEPATH='+db_quote(pj(compiler,'g++.exe')),
-                            '-DBOOST_ROOT='+db_quote(boost_.installdir),
-                            '-DGMP_INCLUDE_DIR='+db_quote( pj(compiler, "..", "include") ),
-                            '-DMPFR_INCLUDE_DIR='+db_quote( pj(compiler, "..", "include") ),
-                            '-DZLIB_INCLUDE_DIR='+db_quote(pj(compiler, "..", "include")),
-                            '-DZLIB_LIBRARY='+db_quote(pj(compiler,"..", "lib", "libz.a")),
-                            #'-DOPENGL_LIBRARIES='+db_quote(pj(compiler,"..", "lib", "libglu32.a")),
-                            ])
-        options=options.replace("\\", "/") #avoid "escape sequence" errors with cmake
-        cmd = 'cmake.exe -G"MinGW Makefiles" '+options+' . '
-        print cmd
-        return subprocess.call(cmd) == 0
-                            
-        
-    
-class rpy2(BaseProjectBuilder):
-    version = "2.3"
-    revision = "f075a4291e9c"
-    url = "https://bitbucket.org/lgautier/rpy2/get/"+revision+".zip"
-    download_name  = "rpy2_src.zip"
-    archive_subdir = "lgautier-rpy2*"
-    
-    cmd_options = [ ("rhome", None, "Path to R.exe") ]
-
-    @option_to_sys_path("rhome")
-    def configure(self):
-        apply_patch( pj(ModuleBaseDir,"rpy2.patch") )
-        return True
-        
-    @option_to_sys_path("rhome")
-    def build(self):
-        cmd = sys.executable + " setup.py build --compiler=mingw32"
-        return subprocess.call(cmd) == 0
-        
-    @option_to_sys_path("rhome")
-    def install(self):
-        cmd = sys.executable + " setup.py install --install-lib=" + self.installdir
+# -*- python -*-
+#
+#       openalea.deploy.dependency_builder
+#
+#       Copyright 2006-2012 INRIA - CIRAD - INRA
+#
+#       File author(s): Daniel Barbeau
+#       File Contributors(s):   
+#                             - Yassin Refahi,
+#                             - Frederic Boudon,
+#
+#       Distributed under the Cecill-C License.
+#       See accompanying file LICENSE.txt or copy at
+#           http://www.cecill.info/licences/Licence_CeCILL-C_V1-en.html
+#
+#       OpenAlea WebSite : http://openalea.gforge.inria.fr
+#
+###############################################################################
+
+####################################################################################################
+# - PROJECT BUILDERS - PROJECT BUILDERS - PROJECT BUILDERS - PROJECT BUILDERS - PROJECT BUILDERS - #
+# !!!!          THE ORDER OF CLASS DEFINITIONS IS THE ORDER OF PROJECT COMPILATION             !!!!#
+####################################################################################################
+class mingwrt(BaseProjectBuilder):
+    url = None
+    supported_tasks = "i"
+    download_name  = "mingw"
+    archive_subdir = None
+    def __init__(self, *args, **kwargs):
+        BaseProjectBuilder.__init__(self, *args, **kwargs)
+        self.sourcedir = pj(Compiler.get_bin_path(), os.pardir)
+        self.install_dll_dir = pj(self.installdir, "dll")
+
+    def install(self):
+        recursive_copy( pj(self.sourcedir, "bin"), self.install_dll_dir, Pattern.dynlib, levels=1)
+        return True
+
+
+
+class qt4(BaseProjectBuilder):
+    version = "4.7.4"
+    #version = "4.8.0"
+    url = "http://get.qt.nokia.com/qt/source/qt-everywhere-opensource-src-"+version+".zip"
+    download_name  = "qt4_src.zip"
+    archive_subdir = "qt-every*"
+
+    def __init__(self, *args, **kwargs):
+        BaseProjectBuilder.__init__(self, *args, **kwargs)
+        # define installation paths
+        self.install_bin_dir = pj(self.installdir, "bin")
+        self.install_dll_dir = pj(self.installdir, "dll")
+        self.install_lib_dir = pj(self.installdir, "lib")
+        self.install_src_dir = pj(self.installdir, "src")
+        self.install_inc_dir = pj(self.installdir, "include")
+        self.install_plu_dir = pj(self.installdir, "dll")
+        self.install_plu_lib_dir = pj(self.installdir, "plugins_lib")
+        self.install_mks_dir = pj(self.installdir, "mkspecs")
+        self.install_tra_dir = pj(self.installdir, "translations")
+        self.inst_paths = [getattr(self, attr) for attr in dir(self) if attr.startswith("install_")\
+                           and attr.endswith("_dir")]
+
+    def new_env_vars(self):
+        if Compiler.version_gt("4.6.0"):
+            return [ ("QMAKESPEC","win32-g++-4.6") ]
+        else:
+            return [ ("QMAKESPEC","win32-g++") ]
+
+    def configure(self):
+        # we must rename syncqt[.bat] files in the bin directory if they exist.
+        syncqtfiles = recursive_glob( "bin", "syncqt*")
+        for sqt in syncqtfiles:
+            os.rename(sqt, sqt+"_no_use")
+            
+        # we must patch the sources in some cases
+        if self.version == "4.8.0" :#and Compiler.version_gt("4.7.0"):
+            apply_patch(  pj(ModuleBaseDir,"qt-4.8.0.patch") )
+            
+        # build the configure command line
+        common = " -release -opensource -shared -nomake demos -nomake examples -mmx -sse2 -3dnow"
+        common += " -declarative -webkit -no-s60 -no-cetest"        
+        cmd = "configure.exe" + common
+        if Compiler.version_gt("4.6.0"):
+            # TDM doesn't ship with DirectX headers. Cannot use Phonon
+            # Actually this is useless as configure.exe will check himself.
+            cmd += " -no-phonon" #  + " -no-declarative"
+        # PIPE is required or else pop.communicate won't do anything!
+        pop = subprocess.Popen(cmd, stdin=subprocess.PIPE)
+        # give enough time for executable to load before it asks for license agreement.
+        time.sleep(2)
+        # accepts license agreement, also waits for configure to finish
+        pop.communicate("y\r")
+        return pop.returncode == 0
+
+    def install(self):
+        # create the installation directories
+        for pth in self.inst_paths:
+            makedirs(pth)
+        # copy binaries
+        recursive_copy( pj(self.sourcedir, "bin"), self.install_bin_dir, Pattern.exe )
+        # add a qt.conf file that tells qmake to look into
+        # directories that are relative to the executable.
+        with open( pj(self.install_bin_dir, "qt.conf"), "w") as qtconf:
+            qtconf.write("[Paths]")
+        # copy dlls
+        recursive_copy( pj(self.sourcedir, "bin"), self.install_dll_dir, Pattern.dynlib )
+        # copy libs
+        recursive_copy( pj(self.sourcedir, "lib"), self.install_lib_dir, Pattern.qtstalib )
+        # copy src -- actually only header files in src --
+        recursive_copy( pj(self.sourcedir, "src"), self.install_src_dir, Pattern.qtsrc )
+        # copy include
+        recursive_copy( pj(self.sourcedir, "include"), self.install_inc_dir, Pattern.qtinc )
+        # copy plugins
+        recursive_copy( pj(self.sourcedir, "plugins"), self.install_plu_dir, Pattern.dynlib, flat=True )
+        # copy plugins
+        recursive_copy( pj(self.sourcedir, "plugins"), self.install_plu_lib_dir, Pattern.qtstalib )
+        # copy plugins
+        recursive_copy( pj(self.sourcedir, "mkspecs"), self.install_mks_dir, Pattern.qtmkspec )
+        # copy translations
+        recursive_copy( pj(self.sourcedir, "translations"), self.install_tra_dir, Pattern.qttransl )
+        self.make_qt_conf()
+        return True
+
+    def extra_paths(self):
+        return pj(self.sourcedir, "bin")
+
+    def make_qt_conf(self, where=None):
+        """ Patch qt *.exes and *.dlls so that they do not contain hard coded paths anymore. """
+        config = ConfigParser.RawConfigParser()
+        sec = "Paths"
+        config.add_section(sec)
+        if where == None:
+            config.set(sec, "Headers",	 "../include")
+            config.set(sec, "Libraries", "../lib")
+            config.set(sec, "Binaries",  "../bin")
+            config.set(sec, "Plugins",   "../dll")
+            #config.set(sec, "Imports"	"no idea")
+            config.set(sec, "Data",      "..")
+            config.set(sec, "Translations", "../translations")
+        else:
+            unix_installdir = self.installdir.replace("\\", "/")
+            config.set(sec, "Headers",	 uj(unix_installdir, "include"))
+            config.set(sec, "Libraries", uj(unix_installdir, "lib"))
+            config.set(sec, "Binaries",  uj(unix_installdir, "bin"))
+            config.set(sec, "Plugins",   uj(unix_installdir, "dll"))
+            #config.set(sec, "Imports"	"no idea")
+            config.set(sec, "Data",      unix_installdir )
+            config.set(sec, "Translations", uj(unix_installdir, "translations")  )      
+        # Writing our configuration file
+        if where is None:
+            where = self.install_bin_dir
+        with open(pj(where, 'qt.conf'), 'w') as configfile:
+            config.write(configfile)
+        return True
+
+
+
+class sip(BaseProjectBuilder):
+    url = "http://www.riverbankcomputing.com/hg/sip/archive/0869eb93c773.zip" #downloading from the mercurial tag
+    #url = "http://www.riverbankcomputing.co.uk/static/Downloads/sip4/sip-4.13.2.zip"
+    download_name  = "sip_src.zip"
+    archive_subdir = "sip*"
+    
+    required_tools = [bisonflex]
+
+    def __init__(self, *args, **kwargs):
+        BaseProjectBuilder.__init__(self, *args, **kwargs)
+        # we install pyqt4 binaries in the qt bin installation directory to easily recover it
+        # for the egg. The eggs are built in the historical layout used by openalea packagers.
+        # This doesn't mean it's good. It doesn't mean it's bad though it does look a bit messy.
+        qt4_ = qt4()
+        self.install_bin_dir  = qt4_.install_bin_dir
+        self.install_site_dir = pj(self.installdir, "site")
+        self.install_inc_dir  = pj(self.installdir, "include")
+        self.install_sip_dir  = pj(self.installdir, "sip")
+
+        self.inst_paths = self.install_bin_dir, self.install_site_dir, self.install_inc_dir, \
+                          self.install_sip_dir
+
+    @option_to_sys_path("bisonflex_path")
+    def configure(self):
+        if exists(pj(self.sourcedir,"configure.py") ):
+            print("it's alive!")
+            # The -S flag is needed or else configure.py
+            # sees any existing sip installation and can fail.
+            return subprocess.call(sys.executable + \
+                   " -S configure.py --platform=win32-g++ -b %s -d %s -e %s -v %s"%self.inst_paths) == 0
+        else:
+            #if configure.py doesn't exist then we might
+            #be using a zipball retreived directly from
+            #sip's mercurial repository. This type of source
+            #needs a step before actually calling configure.py
+            if exists("build.py"):
+                print("Will try to build sip from mercurial source zipball")
+                try:
+                    #We neeeed bison and flex
+                    subprocess.call("bison.exe")
+                except:
+                    print("Could not find bison flex, use --bisonflex")
+                    return False
+                apply_patch( pj(ModuleBaseDir,"sip_build.patch") )
+                subprocess.call(sys.executable + " -S build.py prepare")
+                return self.configure()
+            else:
+                #we don't have a clue of what type of source we're in
+                #so dying cleanly can seem like a good option:
+                return False
+
+    def extra_paths(self):
+        return self.sourcedir, pj(self.sourcedir, "sipgen")
+
+    def extra_python_paths(self):
+        return self.sourcedir, pj(self.sourcedir, "siplib")
+
+    def patch(self):
+        return True
+        # Patching sipconfig.py so that its
+        # paths point to the qt4 egg path we are building.
+        # Feel free to do better
+        header = """
+import re
+from os.path import join as pj
+from pkg_resources import Environment
+
+# Default Path.
+qtdev = os.environ.get('QTDIR') if 'QTDIR' in os.environ else 'C:\\Qt\\4.6.0'
+sip_bin     = pj(sys.prefix,'sip')
+sip_include = pj(sys.prefix, 'include')
+env = Environment()
+if 'qt4' in env:
+    qt = env['qt4'][0].location # Warning: 0 is the active one
+if 'qt4-dev' in env:
+    qtdev       = env['qt4-dev'][0].location # Warning: 0 is the active one
+    sip_bin     = pj(qtdev,'bin','sip.exe')
+    sip_include = pj(qtdev, 'include')
+    """
+
+        txt = ""
+        print("sip patching", os.getcwd())
+        with open("sipconfig.py") as f:
+            txt = f.read()
+
+        # inject our new header
+        txt = txt.replace("import re", header)
+
+        prefix = sys.prefix.replace("\\", r"\\\\")
+        # Evil massive regexp substitutions. RegExp are self-explanatory! Just kidding...
+        txt = re.sub(r"(\s*'default_bin_dir':\s*)'%s'"%prefix,    r"\1sys.prefix", txt)
+        txt = re.sub(r"(\s*'default_mod_dir':\s*)'%s.*'"%prefix,  r"\1pj(sys.prefix,'Lib\site-packages')", txt)
+        txt = re.sub(r"(\s*'default_sip_dir':\s*)'[A-Z]:\\\\.*'", r"\1pj(qtdev,'sip')", txt)
+        txt = re.sub(r"(\s*'py_conf_inc_dir':\s*)'%s.*'"%prefix,  r"\1pj(sys.prefix,'include')", txt)
+        txt = re.sub(r"(\s*'py_inc_dir':\s*)'%s.*'"%prefix,       r"\1pj(sys.prefix,'include')", txt)
+        txt = re.sub(r"(\s*'py_lib_dir':\s*)'%s.*'"%prefix,       r"\1pj(sys.prefix,'libs')", txt)
+        txt = re.sub(r"(\s*'sip_bin':\s*)'[A-Z]:\\\\.*'",         r"\1sip_bin", txt)
+        txt = re.sub(r"(\s*'sip_inc_dir':\s*)'[A-Z]:\\\\.*'",     r"\1sip_include", txt)
+        txt = re.sub(r"(\s*'sip_mod_dir':\s*)'[A-Z]:\\\\.*'",     r"\1qt", txt)
+
+        shutil.copyfile( "sipconfig.py", "sipconfig.py.old" )
+        with open( pj(self.install_site_dir,"sipconfig.py"), "w") as f:
+            f.write(txt)
+
+        return True
+
+
+
+class pyqt4(BaseProjectBuilder) :
+    url = "http://pypi.python.jp/PyQt/PyQt-win-gpl-4.8.6.zip#md5=734bb1b8e6016866f4450211fc4770d9"
+    #url = "http://www.riverbankcomputing.co.uk/static/Downloads/PyQt4/PyQt-win-gpl-4.9.1.zip"
+    download_name  = "pyqt4_src.zip"
+    archive_subdir = "PyQt*"
+    
+    cmd_options = [ ("siphome", None, "Path to sip.exe"),
+                    ("sipsite", None, "Path(s) to sip modules (';' seperated)") ]
+
+    def __init__(self, *args, **kwargs):
+        BaseProjectBuilder.__init__(self, *args, **kwargs)
+        # we install pyqt4 binaries in the qt bin installation directory to easily recover it
+        # for the egg. The eggs are built in the historical layout used by openalea packagers.
+        # This doesn't mean it's good. It doesn't mean it's bad though it does look a bit messy.
+        qt4_ = qt4()
+        self.install_bin_dir  = qt4_.install_bin_dir
+        self.install_site_dir = pj(self.installdir,"site")
+        self.install_sip_dir  = pj(self.installdir,"sip")
+        self.inst_paths       = self.install_bin_dir, self.install_site_dir, self.install_sip_dir
+
+    @option_to_python_path("sipsite")
+    @option_to_sys_path("siphome")
+    def configure(self):
+        # The -S flag is needed or else configure.py
+        # sees any existing sip installation and can fail.
+        # subprocess.call(sys.executable + \
+                      # " -S configure.py --help")
+        # return False
+        qt4_ = qt4()
+        #qtconf_dir = pj(self.sourcedir.replace("\\", "/"),"release")
+        #makedirs( qtconf_dir )
+        #qt4_.make_qt_conf(where=qtconf_dir)
+        return subprocess.call(sys.executable + \
+                      " -S configure.py --confirm-license -w -b %s -d %s -v %s"%self.inst_paths) == 0
+
+    def extra_paths(self):
+        return self.install_bin_dir
+
+    def extra_python_paths(self):
+        return self.install_site_dir
+
+    def patch(self):
+        return True
+        header = """
+import sipconfig
+from sipconfig import pj as pj
+from sipconfig import qtdev as qtdev
+from sipconfig import qt as qt"""
+
+        txt = ""
+        with open("pyqtconfig.py") as f:
+            txt = f.read()
+
+        txt = txt.replace("import sipconfig", header)
+        txt = re.sub(r"(\s*'pyqt_bin_dir':\s*)'[A-Z]:(\\\\|/).*'", r"\1pj(qtdev,'bin')", txt)
+        txt = re.sub(r"(\s*'pyqt_mod_dir':\s*)'[A-Z]:(\\\\|/).*'", r"\1pj(qt,'PyQt4')", txt)
+        txt = re.sub(r"(\s*'pyqt_sip_dir':\s*)'[A-Z]:(\\\\|/).*'", r"\1pj(qtdev,'sip')", txt)
+        txt = re.sub(r"(\s*'qt_data_dir':\s*)'[A-Z]:(\\\\|/).*'",  r"\1qtdev.replace('\\','/')", txt)
+        txt = re.sub(r"(\s*'qt_dir':\s*)'[A-Z]:(\\\\|/).*'",       r"\1qt", txt)
+        txt = re.sub(r"(\s*'qt_inc_dir':\s*)'[A-Z]:(\\\\|/).*'",   r"\1pj(qtdev, 'include')", txt)
+        txt = re.sub(r"(\s*'qt_lib_dir':\s*)'[A-Z]:(\\\\|/).*'",   r"\1pj(qtdev, 'lib')", txt)
+
+        txt = re.sub(r"(\s*'INCDIR_QT':\s*)'[A-Z]:(\\\\|/).*'",    r"\1pj(qtdev, 'include')", txt)
+        txt = re.sub(r"(\s*'LIBDIR_QT':\s*)'[A-Z]:(\\\\|/).*'",    r"\1pj(qtdev, 'lib')", txt)
+        txt = re.sub(r"(\s*'MOC':\s*)'[A-Z]:(\\\\|/).*'",          r"\1pj(qtdev, 'bin', 'moc.exe')", txt)
+
+        shutil.copyfile( "pyqtconfig.py", "pyqtconfig.py.old" )
+        with open("pyqtconfig.py", "w") as f:
+            f.write(txt)
+        prefix = sys.prefix
+
+
+
+class qscintilla(BaseProjectBuilder):
+    url = "http://www.riverbankcomputing.co.uk/static/Downloads/QScintilla2/QScintilla-gpl-2.6.1.zip"
+    download_name  = "qscintilla_src.zip"
+    archive_subdir = "QScint*/Qt4"
+
+    def configure(self):
+        # The install procedure will install qscintilla in qt's installation directories
+        qt4_ = qt4()
+        paths = qt4_.install_inc_dir, qt4_.install_tra_dir, qt4_.installdir, qt4_.install_dll_dir,
+        return subprocess.call( ("qmake -after header.path=%s trans.path=%s qsci.path=%s " + \
+                                 "target.path=%s -spec win32-g++ qscintilla.pro")%paths) == 0
+    def install(self):
+        ret = BaseProjectBuilder.install(self)
+        qt4_ = qt4()
+        try:
+            shutil.move( pj(qt4_.install_dll_dir, "libqscintilla2.a"), qt4_.install_lib_dir)
+        except Exception as epyqt :
+            print(e)
+        return ret
+
+
+
+class pyqscintilla(BaseProjectBuilder):
+    url = None # shares the same as qscintilla
+    download_name  = "qscintilla_src.zip"
+    archive_subdir = "QScint*/Python"
+
+    def __init__(self, *args, **kwargs):
+        BaseProjectBuilder.__init__(self, *args, **kwargs)
+        # define installation paths
+        qsci = qscintilla()
+        qt4_ = qt4()
+        pyqt = pyqt4()
+        self.install_paths = pj(qsci.sourcedir,"release"), pj(qt4_.installdir, "qsci"), \
+                             qsci.sourcedir, pj(pyqt.install_site_dir, "PyQt4"), \
+                             pyqt.install_sip_dir
+        self.qsci_dir = self.install_paths[1]
+
+    def configure(self):
+        # we want pyqscintilla to install itself where pyqt4 installed itself.
+        # -- The -S flag is needed or else configure.py
+        # sees any existing sip installation and can fail. --
+        return subprocess.call(sys.executable + \
+               " -S configure.py -o %s -a %s -n %s -d %s -v %s"%self.install_paths ) == 0
+
+
+
+class qglviewer(BaseProjectBuilder):
+    url = "https://gforge.inria.fr/frs/download.php/28138/libQGLViewer-2.3.9-py.tgz"
+    download_name  = "qglviewer_src.tgz"
+    archive_subdir = "libQGLV*/QGLViewer"
+
+    def __init__(self, *args, **kwargs):
+        BaseProjectBuilder.__init__(self, *args, **kwargs)
+        self.install_inc_dir = pj(self.installdir, "include", "QGLViewer")
+        self.install_dll_dir = pj(self.installdir, "dll")
+        self.install_lib_dir = pj(self.installdir, "lib")
+
+    def configure(self):
+        return subprocess.call("qmake QGLViewer*.pro") == 0
+
+    def build(self):
+        # by default, and since we do not use self.options yet, we build in release mode
+        return subprocess.call("mingw32-make release") == 0
+
+    def install(self):
+        # The install procedure will install qscintilla in qt's directories
+        recursive_copy( self.sourcedir               , self.install_inc_dir, Pattern.include)
+        recursive_copy( pj(self.sourcedir, "release"), self.install_lib_dir, Pattern.qtstalib)
+        recursive_copy( pj(self.sourcedir, "release"), self.install_dll_dir, Pattern.dynlib)
+        return True
+
+    def extra_paths(self):
+        return self.install_dll_dir
+
+
+
+class pyqglviewer(BaseProjectBuilder):
+    url = "https://gforge.inria.fr/frs/download.php/28212/PyQGLViewer-0.9.1.zip"
+    download_name  = "pyqglviewer_src.zip"
+    archive_subdir = "PyQGLV*"
+
+    def __init__(self, *args, **kwargs):
+        BaseProjectBuilder.__init__(self, *args, **kwargs)
+        qglbuilder = qglviewer()
+        self.qglbuilderbase = pj(qglbuilder.sourcedir, os.path.pardir),
+        self.install_sip_dir  = pj(qglbuilder.installdir, "sip")
+        self.install_site_dir = qglbuilder.installdir
+        self.install_exa_dir  = pj(qglbuilder.installdir, "examples")
+
+    def configure(self):
+        # The -S flag is needed or else configure.py
+        # sees any existing sip installation and can fail.
+        return subprocess.call(sys.executable + " -S configure.py -Q %s "%self.qglbuilderbase) == 0
+
+    def install(self):
+        """ pyqglviewer installs itself into the same directory as qglviewer """
+        recursive_copy( pj(self.sourcedir, "build"), self.install_site_dir, Pattern.pyext, levels=1)
+        recursive_copy( pj(self.sourcedir, "src", "sip"), self.install_sip_dir, Pattern.sipfiles, levels=1)
+        recursive_copy( pj(self.sourcedir, "examples"), self.install_exa_dir, Pattern.any)
+        return True
+
+    def extra_python_paths(self):
+        qglbuilder = qglviewer()
+        return qglbuilder.installdir
+
+
+
+class boost(BaseProjectBuilder):
+    url = "http://switch.dl.sourceforge.net/project/boost/boost/1.48.0/boost_1_48_0.zip"
+    download_name  = "boost_src.zip"
+    archive_subdir = "boost*"
+
+    def __init__(self, *args, **kwargs):
+        BaseProjectBuilder.__init__(self, *args, **kwargs)
+        self.install_inc_dir = pj(self.installdir, "include")
+        self.install_lib_dir = pj(self.installdir, "lib")
+
+    def configure(self):
+        return True #bjam configures, builds and installs so nothing to do here
+
+    def build(self):
+        # it is possible to bootstrap boost if no bjam.exe is found:
+        if not exists( pj(self.sourcedir, "bjam.exe") ):
+            print("Call bootstrap.bat")
+            if subprocess.call("bootstrap.bat mingw") != 0:
+                return False
+            else:
+                # The Bootstrapper top-level script ignores that gcc
+                # was used and by default says it's msvc, even though
+                # the lower level scripts used gcc.
+                ascii_file_replace( "project-config.jam",
+                                    "using msvc",
+                                    "using gcc")
+
+        # try to fix a bug in python discovery which prevents
+        # bjam from finding python on Windows NT and old versions.
+        pyjam_pth = pj("tools","build","v2","tools","python.jam")
+        ascii_file_replace(pyjam_pth,
+                           "[ version.check-jam-version 3 1 17 ] || ( [ os.name ] != NT )",
+                           "[ version.check-jam-version 3 1 17 ] && ( [ os.name ] != NT )")
+
+        paths = self.installdir, pj(sys.prefix, "include"), pj(sys.prefix,"libs")
+        cmd = "bjam --debug-configuration --prefix=%s --without-test --layout=system"
+        cmd += " variant=release link=shared threading=multi runtime-link=shared toolset=gcc"
+        cmd += " include=%s library-path=%s install"
+        cmd %= paths
+        print(cmd)
+        return subprocess.call(cmd) == 0
+
+    def install(self):
+        """ bjam configures, builds and installs so nothing to do here"""
+        return self.build()
+
+        
+        
+class ann(BaseProjectBuilder):
+    version = '1.1.2'
+    url = "http://www.cs.umd.edu/~mount/ANN/Files/"+version+"/ann_"+version+".zip"
+    download_name  = "ann_src.zip"
+    archive_subdir = "ann*"
+    enabled = True
+
+    def __init__(self, *args, **kwargs):
+        BaseProjectBuilder.__init__(self, *args, **kwargs)
+        self.patchfile = pj(ModuleBaseDir,"ann_mgw.patch")
+        self.install_inc_dir = pj(self.sourcedir, "include")
+        self.install_lib_dir = pj(self.sourcedir, "lib")
+        
+    def configure(self):
+        apply_patch(self.patchfile)
+        return True
+
+    def build(self):
+        return subprocess.call("mingw32-make win32-g++") == 0
+
+    def install(self):
+        return True
+
+
+
+class gnuplot(BaseProjectBuilder):
+    url = "http://heanet.dl.sourceforge.net/project/gnuplot/gnuplot/4.4.4/gp444win32.zip"
+    download_name  = "gnuplot_src.zip"
+    archive_subdir = "gnuplot*"
+    enabled = False
+
+    def __init__(self, *args, **kwargs):
+        BaseProjectBuilder.__init__(self, *args, **kwargs)
+        self.install_inc_dir = pj(self.installdir, "include")
+        self.install_lib_dir = pj(self.installdir, "lib")
+    def configure(self):
+        return True
+
+    def build(self):
+        return True
+
+    def install(self):
+        return True
+
+
+
+class qhull(BaseProjectBuilder):
+    url = "http://www.qhull.org/download/qhull-2011.2.zip"
+    download_name  = "qhull_src.zip"
+    archive_subdir = "qhull*"
+    enabled = False
+
+    def __init__(self, *args, **kwargs):
+        BaseProjectBuilder.__init__(self, *args, **kwargs)
+        self.install_inc_dir = pj(self.installdir, "include")
+        self.install_lib_dir = pj(self.installdir, "lib")
+    
+    def configure(self):
+        return True
+
+    def build(self):
+        return True
+    
+    def install(self):
+        return True
+
+        
+        
+class cgal(BaseProjectBuilder):
+    url = "https://gforge.inria.fr/frs/download.php/30390/CGAL-4.0.zip"
+    download_name  = "cgal_src.zip"
+    archive_subdir = "cgal*"
+    required_tools = [cmake]
+    enabled = True
+    version = "4.0"
+    def __init__(self, *args, **kwargs):
+        BaseProjectBuilder.__init__(self, *args, **kwargs)
+        self.install_inc_dir = pj(self.installdir, "include")
+        self.install_lib_dir = pj(self.installdir, "lib")
+    
+    def configure(self):
+        compiler = Compiler.get_bin_path()
+        boost_ = boost()
+        
+        db_quote = lambda x: '"'+x+'"'
+        
+        options = " ".join(['-DCMAKE_INSTALL_PREFIX='+db_quote(self.installdir),
+                            '-DCMAKE_CXX_COMPILER:FILEPATH='+db_quote(pj(compiler,'g++.exe')),
+                            '-DBOOST_ROOT='+db_quote(boost_.installdir),
+                            '-DGMP_INCLUDE_DIR='+db_quote( pj(compiler, "..", "include") ),
+                            '-DMPFR_INCLUDE_DIR='+db_quote( pj(compiler, "..", "include") ),
+                            '-DZLIB_INCLUDE_DIR='+db_quote(pj(compiler, "..", "include")),
+                            '-DZLIB_LIBRARY='+db_quote(pj(compiler,"..", "lib", "libz.a")),
+                            #'-DOPENGL_LIBRARIES='+db_quote(pj(compiler,"..", "lib", "libglu32.a")),
+                            ])
+        options=options.replace("\\", "/") #avoid "escape sequence" errors with cmake
+        cmd = 'cmake.exe -G"MinGW Makefiles" '+options+' . '
+        print(cmd)
+        return subprocess.call(cmd) == 0
+                            
+        
+    
+class rpy2(BaseProjectBuilder):
+    version = "2.3"
+    revision = "f075a4291e9c"
+    url = "https://bitbucket.org/lgautier/rpy2/get/"+revision+".zip"
+    download_name  = "rpy2_src.zip"
+    archive_subdir = "lgautier-rpy2*"
+    
+    cmd_options = [ ("rhome", None, "Path to R.exe") ]
+
+    @option_to_sys_path("rhome")
+    def configure(self):
+        apply_patch( pj(ModuleBaseDir,"rpy2.patch") )
+        return True
+        
+    @option_to_sys_path("rhome")
+    def build(self):
+        cmd = sys.executable + " setup.py build --compiler=mingw32"
+        return subprocess.call(cmd) == 0
+        
+    @option_to_sys_path("rhome")
+    def install(self):
+        cmd = sys.executable + " setup.py install --install-lib=" + self.installdir
         return subprocess.call(cmd) == 0
\ No newline at end of file
diff --git a/src/openalea/deploy/system_dependencies/qtpatch.py b/src/openalea/deploy/system_dependencies/qtpatch.py
index 8b5fa93..e82c491 100644
--- a/src/openalea/deploy/system_dependencies/qtpatch.py
+++ b/src/openalea/deploy/system_dependencies/qtpatch.py
@@ -1,108 +1,108 @@
-# -*- python -*-
-#
-#       openalea.deploy.qtpatch
-#
-#       Copyright 2006-2011 INRIA - CIRAD - INRA
-#
-#       File author(s): Daniel Barbeau
-#
-#       Distributed under the Cecill-C License.
-#       See accompanying file LICENSE.txt or copy at
-#           http://www.cecill.info/licences/Licence_CeCILL-C_V1-en.html
-#
-#       OpenAlea WebSite : http://openalea.gforge.inria.fr
-#
-###############################################################################
-
-"""This module converts hard coded compilation paths inside Qt binairies into
-relative paths suitable for use inside eggs."""
-
-__license__ = "Cecill-C"
-__revision__ = " $Id$"
-
-import sys
-import os, os.path
-import fnmatch
-import shutil
-
-def patch(files, qtDirPath, where):
-    if not os.path.isdir(qtDirPath):
-        print qtDirPath, "does not exist"
-        sys.exit(-1)
-    
-    if os.path.exists( files ):
-        with open(files, "r") as fn:
-            filesToPatch = fn.read().split()            
-    else:
-        filesToPatch = []
-        patterns = files.split(",")
-        for dir_path, sub_dirs, subfiles in os.walk(where):
-            for pat in patterns:
-                for fn in fnmatch.filter(subfiles, pat):
-                    filesToPatch.append( os.path.join(dir_path, fn) )
-  
-    # Make all paths relative to the patched file.
-    # PortableExecutables have file size encoded in header.
-    # Instead of modifying the header we replace by a string 
-    # of exactly the same size using padding "/".
-    replacement = bytearray(".." + "/"*(len(qtDirPath)-2))
-    qtDirPathA  = bytearray(qtDirPath)
-    qtDirPathA2 = bytearray(qtDirPath.replace("\\", "/"))
-    patches     = 0 # a counter 
-    
-    print "about to try to patch", len(filesToPatch), "files"
-    for f in filesToPatch:
-        prefix = u"" + qtDirPath
-        f = os.path.join(prefix,f)
-        
-        print "patch file", f,
-        if not os.path.exists(f):
-            print "qpatch: warning: file not found", f
-            continue
-              
-        source = None
-        stat   = None
-        with open(f, "rb") as file_:
-            source = bytearray(file_.read())
-            # store permissions
-            stat = os.fstat(file_.fileno())
-            
-        if source.find(qtDirPathA) == -1 and source.find(qtDirPathA2) == -1:
-            print "string not found"
-            continue
-  
-        # make backup, if backup already exists, skip the patching.
-        if not os.path.exists( f+"_bkp" ):
-            shutil.move(f, f+"_bkp")
-        else:
-            print "backup already exists, ignoring"
-            continue
-  
-        patched = source.replace(qtDirPathA, replacement)
-        patched = patched.replace(qtDirPathA2, replacement)
-               
-        with open( f, "wb") as out_:
-            out_.write(patched)
-        
-            # restore permissions
-            try:
-                os.fchmod(out_.fileno(), stat.st_mode)
-                os.fchown(out_.fileno(), stat.st_uid, stat.st_gid)
-            except Exception, e:
-                print "\n\tOops! Couldn't copy file metadata", type(e), e
-        
-        patches += 1
-        print "ok"
-            
-    print "patched", patches, "files"
-    
-if __name__ == "__main__":
-    try:
-        files, qtDirPath, where = sys.argv[1:]
-        patch(files, qtDirPath, where)
-    except:
-        import traceback
-        traceback.print_exc()
-        print "Usage: python patch files oldQtDir where"
-        sys.exit(-1)    
+# -*- python -*-
+#
+#       openalea.deploy.qtpatch
+#
+#       Copyright 2006-2011 INRIA - CIRAD - INRA
+#
+#       File author(s): Daniel Barbeau
+#
+#       Distributed under the Cecill-C License.
+#       See accompanying file LICENSE.txt or copy at
+#           http://www.cecill.info/licences/Licence_CeCILL-C_V1-en.html
+#
+#       OpenAlea WebSite : http://openalea.gforge.inria.fr
+#
+###############################################################################
+
+"""This module converts hard coded compilation paths inside Qt binairies into
+relative paths suitable for use inside eggs."""
+
+__license__ = "Cecill-C"
+__revision__ = " $Id$"
+
+import sys
+import os, os.path
+import fnmatch
+import shutil
+
+def patch(files, qtDirPath, where):
+    if not os.path.isdir(qtDirPath):
+        print(qtDirPath, "does not exist")
+        sys.exit(-1)
+    
+    if os.path.exists( files ):
+        with open(files, "r") as fn:
+            filesToPatch = fn.read().split()            
+    else:
+        filesToPatch = []
+        patterns = files.split(",")
+        for dir_path, sub_dirs, subfiles in os.walk(where):
+            for pat in patterns:
+                for fn in fnmatch.filter(subfiles, pat):
+                    filesToPatch.append( os.path.join(dir_path, fn) )
+  
+    # Make all paths relative to the patched file.
+    # PortableExecutables have file size encoded in header.
+    # Instead of modifying the header we replace by a string 
+    # of exactly the same size using padding "/".
+    replacement = bytearray(".." + "/"*(len(qtDirPath)-2))
+    qtDirPathA  = bytearray(qtDirPath)
+    qtDirPathA2 = bytearray(qtDirPath.replace("\\", "/"))
+    patches     = 0 # a counter 
+    
+    print("about to try to patch", len(filesToPatch), "files")
+    for f in filesToPatch:
+        prefix = "" + qtDirPath
+        f = os.path.join(prefix,f)
+        
+        print("patch file", f)
+        if not os.path.exists(f):
+            print("qpatch: warning: file not found", f)
+            continue
+              
+        source = None
+        stat   = None
+        with open(f, "rb") as file_:
+            source = bytearray(file_.read())
+            # store permissions
+            stat = os.fstat(file_.fileno())
+            
+        if source.find(qtDirPathA) == -1 and source.find(qtDirPathA2) == -1:
+            print("string not found")
+            continue
+  
+        # make backup, if backup already exists, skip the patching.
+        if not os.path.exists( f+"_bkp" ):
+            shutil.move(f, f+"_bkp")
+        else:
+            print("backup already exists, ignoring")
+            continue
+  
+        patched = source.replace(qtDirPathA, replacement)
+        patched = patched.replace(qtDirPathA2, replacement)
+               
+        with open( f, "wb") as out_:
+            out_.write(patched)
+        
+            # restore permissions
+            try:
+                os.fchmod(out_.fileno(), stat.st_mode)
+                os.fchown(out_.fileno(), stat.st_uid, stat.st_gid)
+            except Exception as e:
+                print("\n\tOops! Couldn't copy file metadata", type(e), e)
+        
+        patches += 1
+        print("ok")
+            
+    print("patched", patches, "files")
+    
+if __name__ == "__main__":
+    try:
+        files, qtDirPath, where = sys.argv[1:]
+        patch(files, qtDirPath, where)
+    except:
+        import traceback
+        traceback.print_exc()
+        print("Usage: python patch files oldQtDir where")
+        sys.exit(-1)    
     
\ No newline at end of file
diff --git a/src/openalea/deploy/system_dependencies/rpy2_setup.py b/src/openalea/deploy/system_dependencies/rpy2_setup.py
index 716e847..2aee913 100644
--- a/src/openalea/deploy/system_dependencies/rpy2_setup.py
+++ b/src/openalea/deploy/system_dependencies/rpy2_setup.py
@@ -16,7 +16,7 @@ if sys.platform == "win32":
         if ctypes.windll.kernel32.GetShortPathNameW(path, ctypes.pointer(out), nsize):
             return ctypes.wstring_at(path)
         else:
-            print ctypes.windll.kernel32.GetLastError()
+            print(ctypes.windll.kernel32.GetLastError())
 
 
 pack_name = 'rpy2'
@@ -163,7 +163,7 @@ class build_ext(_build_ext):
                       'LAPACK_LIBS', 'BLAS_LIBS'):
             config += get_rconfig(r_home, about)            
 
-        print(config.__repr__())
+        print((config.__repr__()))
 
         self.include_dirs.extend(config._include_dirs)
         self.libraries.extend(config._libraries)
@@ -270,7 +270,7 @@ class RConfig(object):
                     break
                 elif rconfig_m is None:
                     if allow_empty and (rconfig == ''):
-                        print(cmd + '\nreturned an empty string.\n')
+                        print((cmd + '\nreturned an empty string.\n'))
                         rc += RConfig()
                         ok = True
                         break
@@ -320,8 +320,8 @@ def get_rconfig(r_home, about, allow_empty = False):
         arch = 'i386'
         inc_dirs     = os.path.join(r_home, 'include')
         arch_inc_dir = os.path.join(r_home, 'etc', arch)
-        print os.path.join(r_home, 'include')
-        print arch_inc_dir
+        print(os.path.join(r_home, 'include'))
+        print(arch_inc_dir)
         d = get_makeconf_dict(r_home, arch)
         if about == "--cppflags":
             rconfig = d.get("ALL_CPPFLAGS") + r' -I"%s" -I"%s"'%(inc_dirs, arch_inc_dir)
@@ -340,7 +340,7 @@ def get_rconfig(r_home, about, allow_empty = False):
         if rconfig.startswith("WARNING"):
             rconfig = rp.readline()
         rp.close()
-    print rconfig
+    print(rconfig)
     rconfig = rconfig.strip()
     rc = RConfig.from_string(rconfig, allow_empty = allow_empty)
     return rc
@@ -406,7 +406,7 @@ def parse_make(makefile, initial_vars=None):
         vardict.update(initial_vars)
             
     # expand variables
-    for var, value in vardict.copy().iteritems():
+    for var, value in vardict.copy().items():
         expand = var_re2.search(value) #something to expand
         while (expand):
             value  = expand.group(1) + vardict.get(expand.group(2), "") + expand.group(3)  
@@ -510,7 +510,7 @@ if __name__ == '__main__':
     pack_dir = {pack_name: os.path.join(package_prefix, 'rpy')}
 
     import distutils.command.install
-    for scheme in distutils.command.install.INSTALL_SCHEMES.values():
+    for scheme in list(distutils.command.install.INSTALL_SCHEMES.values()):
         scheme['data'] = scheme['purelib']
 
     setup(
diff --git a/src/openalea/deploy/system_dependencies/ubuntu_release.py b/src/openalea/deploy/system_dependencies/ubuntu_release.py
index edd895a..791348d 100644
--- a/src/openalea/deploy/system_dependencies/ubuntu_release.py
+++ b/src/openalea/deploy/system_dependencies/ubuntu_release.py
@@ -47,7 +47,7 @@ openalea_meta
     #secondnature
     #openalea_dev
 
-    pkgs = filter(None, pkgs.split('\n'))
+    pkgs = [_f for _f in pkgs.split('\n') if _f]
     pkgs = OrderedDict.fromkeys(pkgs,VERSION)
     return pkgs
 
@@ -69,7 +69,7 @@ image
 pylab
 openalea
 """
-    pkgs = filter(None, pkgs.split('\n'))
+    pkgs = [_f for _f in pkgs.split('\n') if _f]
 
     return pkgs
 
@@ -100,7 +100,7 @@ aml2py
 """
     #TODO: flowerdemo
 
-    pkgs = filter(None, pkgs.split('\n'))
+    pkgs = [_f for _f in pkgs.split('\n') if _f]
     pkgs = OrderedDict.fromkeys(pkgs,VERSION)
     pkgs['PlantGL']="2.16.1~ppa3"
     pkgs['lpy']="2.1.0~ppa3"
@@ -116,7 +116,7 @@ svgdraw
 mechanics
 physics
 """
-    pkgs = filter(None, pkgs.split('\n'))
+    pkgs = [_f for _f in pkgs.split('\n') if _f]
     pkgs = OrderedDict.fromkeys(pkgs,VERSION)
     return pkgs
 
@@ -131,7 +131,7 @@ tissueview
 vmanalysis
 tissue_meta
 """
-    pkgs = filter(None, pkgs.split('\n'))
+    pkgs = [_f for _f in pkgs.split('\n') if _f]
     pkgs = OrderedDict.fromkeys(pkgs,VERSION)
     return pkgs
 
@@ -146,7 +146,7 @@ pyratp
 topvine
 alinea_meta
 """
-    pkgs = filter(None, pkgs.split('\n'))
+    pkgs = [_f for _f in pkgs.split('\n') if _f]
     pkgs = OrderedDict.fromkeys(pkgs,VERSION)
     pkgs['caribu']="6.0.3~ppa1"
     return pkgs
@@ -175,7 +175,7 @@ aml2py
 vplants
 """
     # TODO: vplants_dev, flowerdemo
-    pkgs_name = filter(None, pkgs_name.split('\n'))
+    pkgs_name = [_f for _f in pkgs_name.split('\n') if _f]
     return pkgs_name
 
 def my_dch(packages, my_path='.', distribution = 'precise', dry_run=False):
@@ -184,10 +184,10 @@ def my_dch(packages, my_path='.', distribution = 'precise', dry_run=False):
     """
     cwd = os.getcwd()
     os.chdir(my_path)
-    for p, version in packages.iteritems():
+    for p, version in packages.items():
         os.chdir(p)
         cmd = cmd_dch%(distribution,version)
-        print "%s: \n"%p + '\t'+cmd
+        print("%s: \n"%p + '\t'+cmd)
         if not dry_run:
             os.system(cmd)
         os.chdir('..')
@@ -201,7 +201,7 @@ def my_debuild(packages, my_path='.', dry_run=False):
     os.chdir(my_path)
     for p in packages:
         os.chdir(p)
-        print "%s: \n"%p + '\t'+cmd_debuild
+        print("%s: \n"%p + '\t'+cmd_debuild)
         if not dry_run:
             os.system(cmd_debuild)
         os.chdir('..')
@@ -217,21 +217,21 @@ def my_dput(packages, dist = 'openalea', my_path='.', dry_run=False):
         files = d.files('*%s_*.changes'%p)
         changes = sorted([str(f) for f in files])
         if not changes:
-            print "ERROR: %s not found"%p
+            print("ERROR: %s not found"%p)
             errors.append(p)
             continue
-        print '\n ', p
-        print changes
+        print('\n ', p)
+        print(changes)
         my_file = changes[-1]
-        print my_file
+        print(my_file)
 
         cmd = cmd_dput%(dist,) + my_file
-        print cmd 
+        print(cmd) 
         if not dry_run:
             os.system(cmd)
-        print '#####################'
+        print('#####################')
 
-    print '\n'.join(errors)
+    print('\n'.join(errors))
     os.chdir(cwd)
     return
 
diff --git a/src/openalea/deploy/util.py b/src/openalea/deploy/util.py
index cdba2f9..706fd83 100644
--- a/src/openalea/deploy/util.py
+++ b/src/openalea/deploy/util.py
@@ -176,7 +176,7 @@ def check_system():
     Return a dictionnary containing environment variables to be set.
     """
 
-    from install_lib import get_dyn_lib_dir
+    from .install_lib import get_dyn_lib_dir
 
     in_env = dict(os.environ)
     out_env = {}
@@ -234,8 +234,8 @@ def check_system():
             out_env['PATH'] = ':'.join(paths)
 
 
-    except Exception, e:
-        print e
+    except Exception as e:
+        print (e)
 
     return out_env
 
@@ -244,31 +244,45 @@ def check_system():
 
 def get_repo_list():
     """ Return the list of OpenAlea repository """
-    import urllib
+    try:
+        # Python 3
+        from urllib.request import urlopen
+    except:
+        # Python 2
+        from urllib import urlopen
     try:
         ret = []
-        u = urllib.urlopen(OPENALEA_REPOLIST)
+        u = urlopen(OPENALEA_REPOLIST)
         for i in u:
             ret.append(i.strip())
+        if sys.version_info[0] > 2:
+            ret = [x.decode('utf-8') for x in ret]
         return ret
 
-    except Exception, e:
-        print e
+    except Exception as e:
+        print (e)
         return [OPENALEA_PI]
 
 
 def get_recommended_prefix():
     """ Return the list of recommended package prefix """
-    import urllib
+    try:
+        # Python 3
+        from urllib.request import urlopen
+    except:
+        # Python 2
+        from urllib import urlopen
     try:
         ret = []
-        prefixes = urllib.urlopen(OPENALEA_RECOMMENDED_PKG)
+        prefixes = urlopen(OPENALEA_RECOMMENDED_PKG)
         for i in prefixes:
             ret.append(i.strip())
+        if sys.version_info[0] > 2:
+            ret = [x.decode('utf-8') for x in ret]
         return ret
 
-    except Exception, e:
-        print e
+    except Exception as e:
+        print (e)
         return ["openalea"]
 
 
@@ -282,12 +296,35 @@ def is_virtual_env():
 def is_conda_env():
     """ Return True if we are in a conda env
 
-    The CONDA_ENVPATH environment variable is set by the activate conda script.
+    The CONDA_PREFIX environment variable is set by the activate conda script.
     """
 
     return ('CONDA_PREFIX' in os.environ)
 
 
+def conda_prefix():
+    """ Return the conda prefix
+
+    The prefix is the path where libs, bins and includes need to be installed.
+    Use this function only in a conda environment (is_conda_env() is True)
+    """
+    if 'CONDA_BUILD' in os.environ:
+        prefix = os.environ['PREFIX']
+    else:
+        prefix = os.environ['CONDA_PREFIX']
+
+    return os.path.abspath(prefix)
+
+def is_conda_build():
+    """ Return True if we are in a conda env
+
+    The CONDA_BUILD environment variable is set by the activate conda script.
+
+    ..seealso:: `Conda Environment Variables <https://conda.io/docs/using/envs.html>`_
+    """
+    return ('CONDA_BUILD' in os.environ)
+
+
 def get_metadata(name):
     """return metadata of an egg
 
diff --git a/src/openalea/deploy/version.py b/src/openalea/deploy/version.py
index 050efac..159d47f 100644
--- a/src/openalea/deploy/version.py
+++ b/src/openalea/deploy/version.py
@@ -2,8 +2,13 @@
 #  -*- coding: utf-8 -*-
 
 major = 2
+"""(int) Version major component."""
+
 minor = 1
-post = 1
+"""(int) Version minor component."""
+
+post = 6
+"""(int) Version post or bugfix component."""
 
 __version__ = ".".join([str(s) for s in (major, minor, post)])
 # #}
diff --git a/travis.yml b/travis.yml
new file mode 100644
index 0000000..7267e90
--- /dev/null
+++ b/travis.yml
@@ -0,0 +1,47 @@
+language: cpp
+
+os:
+  - linux
+  - osx
+
+sudo: required
+
+services:
+  - docker
+  
+env:
+ - CONDA_RECIPE=conda
+   CONDA_VERSION=2
+ - CONDA_RECIPE=conda
+   CONDA_VERSION=3
+   
+install:
+  - git clone https://github.com/OpenAlea/travis-ci.git
+  - cd travis-ci
+  - source install.sh
+
+before_script:
+  - source before_script.sh
+
+script:
+  - source script.sh
+
+after_success:
+  - source after_success.sh
+
+after_failure:
+  - source after_failure.sh
+
+before_deploy:
+  - source before_deploy.sh
+
+deploy:
+  skip_cleanup: true
+  provider: script
+  script: bash deploy_script.sh
+
+after_deploy:
+  - source after_deploy.sh
+
+after_script:
+  - source after_script.sh
